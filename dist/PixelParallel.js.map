{"version":3,"sources":["webpack:///PixelParallel.js","webpack:///webpack/bootstrap fd38e2883e8fc55d4c96","webpack:///./~/vue-loader/lib/component-normalizer.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/vue-style-loader/lib/addStylesClient.js","webpack:///./src/utils/utils.js","webpack:///./src/directives/draggable.js","webpack:///(webpack)/buildin/global.js","webpack:///./~/immediate/lib/browser.js","webpack:///./src/PixelParallel.vue","webpack:///./~/vue/dist/vue.common.js","webpack:///./~/argsarray/index.js","webpack:///PixelParallel.vue","webpack:///Droparea.vue","webpack:///Number.vue","webpack:///Overlay.vue","webpack:///OverlayGrids.vue","webpack:///OverlayImage.vue","webpack:///OverlayRulers.vue","webpack:///Panel.vue","webpack:///PasteBox.vue","webpack:///Toggle.vue","webpack:///UploadButton.vue","webpack:///./src/main.js","webpack:///./src/styles/panel-fonts.js","webpack:///./src/styles/panel-icons.js","webpack:///./src/styles/panel.js","webpack:///./src/utils/db.js","webpack:///./src/PixelParallel.vue?9d26","webpack:///./src/components/OverlayImage.vue?7ea0","webpack:///./src/components/Panel.vue?a100","webpack:///./src/components/OverlayRulers.vue?7b90","webpack:///./src/components/Overlay.vue?5cd7","webpack:///./src/components/OverlayGrids.vue?3749","webpack:///./~/debug/src/browser.js","webpack:///./~/debug/src/debug.js","webpack:///./~/events/events.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/lie/lib/browser.js","webpack:///./~/mousetrap/mousetrap.js","webpack:///./~/mousetrap/plugins/pause/mousetrap-pause.js","webpack:///./~/ms/index.js","webpack:///./~/pouchdb/lib/index-browser.js","webpack:///./~/process/browser.js","webpack:///./~/spark-md5/spark-md5.js","webpack:///./src/components/Droparea.vue","webpack:///./src/components/Number.vue","webpack:///./src/components/Overlay.vue","webpack:///./src/components/OverlayGrids.vue","webpack:///./src/components/OverlayImage.vue","webpack:///./src/components/OverlayRulers.vue","webpack:///./src/components/Panel.vue","webpack:///./src/components/PasteBox.vue","webpack:///./src/components/Toggle.vue","webpack:///./src/components/UploadButton.vue","webpack:///./src/PixelParallel.vue?0f6b","webpack:///./src/components/OverlayImage.vue?379b","webpack:///./src/components/UploadButton.vue?024c","webpack:///./src/components/PasteBox.vue?1898","webpack:///./src/components/Panel.vue?36b0","webpack:///./src/components/Toggle.vue?419c","webpack:///./src/components/OverlayRulers.vue?e14b","webpack:///./src/components/Droparea.vue?b2a5","webpack:///./src/components/Number.vue?9064","webpack:///./src/components/Overlay.vue?36c1","webpack:///./src/components/OverlayGrids.vue?256c","webpack:///./src/PixelParallel.vue?b7b8","webpack:///./src/components/OverlayImage.vue?afb8","webpack:///./src/components/Panel.vue?1f65","webpack:///./src/components/OverlayRulers.vue?4bcb","webpack:///./src/components/Overlay.vue?d868","webpack:///./src/components/OverlayGrids.vue?44b2","webpack:///./~/vue-style-loader/lib/listToStyles.js","webpack:///./~/vuvuzela/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","type","default","options","render","staticRenderFns","_scopeId","computed","keys","forEach","key","list","toString","result","this","length","item","push","join","mediaQuery","alreadyImportedModules","id","addStylesToDom","styles","domStyle","stylesInDom","refs","j","parts","addStyle","createStyleElement","styleElement","document","createElement","head","appendChild","obj","update","remove","querySelector","isProduction","noop","parentNode","removeChild","isOldIE","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","applyToTag","newObj","css","media","sourceMap","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","insertBefore","setAttribute","sources","btoa","unescape","encodeURIComponent","JSON","stringify","firstChild","hasDocument","DEBUG","Error","listToStyles","getElementsByTagName","navigator","test","userAgent","toLowerCase","parentId","_isProduction","newList","mayRemove","textStore","replacement","filter","Boolean","__webpack_exports__","_defineProperty","writable","getFileTypeFromBase64string","input","replace","split","getBase64FromFile","file","Promise","resolve","reject","reader","window","FileReader","onload","onerror","readAsDataURL","getImageFromPasteEvent","event","_this","clipboardData","items","Array","from","some","kind","getAsFile","imageType","then","base64string","waitInterval","setInterval","target","children","clearInterval","src","innerHTML","getImageFromInputEvent","files","isObject","_typeof","isArray","mergeDeep","source","assign","Symbol","iterator","constructor","draggableElement","element","settings","elementDraggable","startPosition","left","top","elementMargin","elementInitialMargin","mouseUpHandler","removeEventListener","mouseMoveHandler","onDragEnd","onDragMove","y","pageY","style","marginTop","x","pageX","marginLeft","mouseDownHandler","preventDefault","onDragStart","parseInt","addEventListener","inserted","el","bindings","g","Function","eval","e","global","nextTick","draining","oldQueue","len","queue","immediate","task","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","called","observer","observe","characterData","data","setImmediate","MessageChannel","scriptEl","onreadystatechange","documentElement","setTimeout","channel","port1","onmessage","port2","postMessage","Component","isUndef","v","undefined","isDef","isTrue","isFalse","isPrimitive","isPlainObject","_toString","isRegExp","val","String","toNumber","parseFloat","isNaN","makeMap","str","expectsLowerCase","map","create","arr","indexOf","splice","hasOwn","cached","fn","cache","ctx","boundFn","a","arguments","apply","_length","toArray","start","ret","extend","to","_from","toObject","res","looseEqual","b","isObjectA","isObjectB","looseIndexOf","once","isReserved","charCodeAt","def","parsePath","path","bailRE","segments","handleError","err","vm","info","config","errorHandler","inBrowser","console","error","isNative","Ctor","pushTarget","_target","Dep","targetStack","popTarget","pop","protoAugment","__proto__","copyAugment","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","dep","getOwnPropertyDescriptor","setter","set","childOb","depend","dependArray","newVal","notify","Math","max","del","mergeData","toVal","fromVal","mergeHook","parentVal","childVal","concat","mergeAssets","normalizeProps","props","camelize","normalizeDirectives","dirs","directives","mergeOptions","parent","child","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","resolveAsset","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","prop","absent","isType","hyphenate","getPropDefaultValue","prevShouldConvert","$options","_props","getType","match","createTextVNode","VNode","cloneVNode","vnode","cloned","tag","text","elm","context","componentOptions","ns","isStatic","isComment","isCloned","cloneVNodes","vnodes","createFnInvoker","fns","invoker","arguments$1","updateListeners","on","oldOn","add","remove$$1","cur","old","normalizeEvent","capture","passive","mergeVNodeHook","hookKey","hook","wrappedHook","oldHook","merged","extractPropsFromVNodeData","attrs","altKey","checkProp","hash","preserve","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","isTextNode","node","nestedIndex","last","_isVList","ensureCtor","comp","base","resolveAsyncComponent","factory","baseCtor","errorComp","resolved","loading","loadingComp","contexts","sync","forceRender","$forceUpdate","reason","component","delay","timeout","getFirstComponentChild","initEvents","_events","_hasHookEvent","listeners","_parentListeners","updateComponentListeners","once$$1","$once","$on","remove$1","$off","oldListeners","resolveSlots","slots","defaultSlot","functionalContext","slot","every","isWhitespace","resolveScopedSlots","initLifecycle","abstract","$parent","$children","$root","$refs","_watcher","_inactive","_directInactive","_isMounted","_isDestroyed","_isBeingDestroyed","mountComponent","hydrating","$el","createEmptyVNode","callHook","updateComponent","_update","_render","Watcher","$vnode","updateChildComponent","parentVnode","renderChildren","hasChildren","_renderChildren","scopedSlots","$scopedSlots","emptyObject","_parentVnode","_vnode","propKeys","_propKeys","$slots","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","handlers","$emit","resetSchedulerState","activatedChildren","has","waiting","flushing","flushSchedulerQueue","watcher","sort","run","activatedQueue","slice","updatedQueue","callActivatedHooks","callUpdateHooks","devtools","emit","queueActivatedComponent","queueWatcher","traverse","seenObjects","clear","_traverse","seen","isA","depId","proxy","sourceKey","sharedPropertyDefinition","initState","_watchers","opts","initProps","methods","initMethods","initData","_data","initComputed","watch","initWatch","propsOptions","isRoot","getData","watchers","_computedWatchers","userDef","computedWatcherOptions","defineComputed","createComputedGetter","dirty","evaluate","handler","createWatcher","$watch","initProvide","provide","_provided","initInjections","resolveInject","inject","hasSymbol","Reflect","ownKeys","provideKey","createFunctionalComponent","mergeProps","_context","h","injections","functionalOptions","createComponent","_base","cid","resolveConstructorOptions","model","transformModel","functional","nativeOn","mergeHooks","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","_isComponent","_componentTag","_parentElm","_refElm","inlineTemplate","hooksToMerge","fromParent","ours","componentVNodeHooks","mergeHook$1","one","two","callback","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","SIMPLE_NORMALIZE","getTagNamespace","isReservedTag","parsePlatformTagName","applyNS","renderList","renderSlot","fallback","bindObject","scopedSlotFn","slotNodes","resolveFilter","identity","checkKeyCodes","eventKeyCode","builtInAlias","keyCodes","bindObjectProps","asProp","mustUseProp","domProps","renderStatic","isInFor","tree","_staticTrees","_renderProxy","markStatic","markOnce","isOnce","markStaticNode","initRender","renderContext","_c","$createElement","initInternalComponent","super","superOptions","modifiedOptions","resolveModifiedOptions","extendOptions","components","modified","latest","extended","sealed","sealedOptions","dedupe","Vue$3","_init","initUse","Vue","use","plugin","installed","args","unshift","install","initMixin$1","mixin","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","initProps$1","initComputed$1","ASSET_TYPES","Comp","initAssetRegisters","definition","getComponentName","matches","pattern","pruneCache","current","cachedNode","pruneCacheEntry","componentInstance","$destroy","genClassForVnode","childNode","mergeClassData","genClassFromData","staticClass","class","dynamicClass","stringifyClass","stringified","isSVG","isUnknownElement","unknownElementCache","HTMLUnknownElement","HTMLElement","query","selected","createElement$1","tagName","multiple","createElementNS","namespace","namespaceMap","createComment","newNode","referenceNode","nextSibling","setTextContent","textContent","registerRef","isRemoval","ref","refInFor","sameVnode","sameInputType","createKeyToOldIdx","beginIdx","endIdx","updateDirectives","oldVnode","oldDir","dir","isCreate","emptyNode","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","callHook$1","componentUpdated","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","updateAttrs","oldAttrs","setAttr","isIE9","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","removeAttribute","isBooleanAttr","isFalsyAttrValue","setAttributeNS","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","parseFilters","exp","pushFilter","filters","lastFilterIndex","trim","prev","expression","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","charAt","validDivisionCharRE","wrapFilter","baseWarn","msg","pluckModuleFunction","_","addProp","addAttr","addDirective","arg","addHandler","important","warn","events","native","nativeEvents","newHandler","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","attrsMap","attrsList","genComponentModel","number","valueExpression","assignment","genAssignmentCode","modelRs","parseModel","idx","index$1","expressionPos","expressionEndPos","lastIndexOf","eof","chr","next","isStringStart","parseString","parseBracket","substring","inBracket","stringQuote","_warn","warn$1","genSelect","genCheckboxModel","genRadioModel","genDefaultModel","valueBinding","trueValueBinding","falseValueBinding","CHECKBOX_RADIO_TOKEN","selectedVal","code","lazy","needCompositionGuard","RANGE_TOKEN","normalizeEvents","isIE","isChrome","add$1","oldHandler","target$1","ev","remove$2","supportsPassive","updateDOMListeners","updateDOMProps","oldProps","_value","strCur","shouldUpdateValue","checkVal","composing","isDirty","isInputChanged","activeElement","_vModifiers","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","normalizedStyle","oldStyle","newStyle","setProp","addClass","classList","getAttribute","removeClass","tar","resolveTransition","def$$1","autoCssTransition","nextFrame","raf","addTransitionClass","removeTransitionClass","whenTransitionEnds","expectedType","cb","getTransitionInfo","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","end","onEnd","getComputedStyle","transitionDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","Number","enter","toggleDisplay","_leaveCb","cancelled","transition","_enterCb","nodeType","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","activeInstance","transitionNode","isAppear","isRootInsert","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","rm","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","explicitLeaveDuration","afterLeave","leaveCancelled","delayLeave","invokerFns","_enter","setSelected","binding","isMultiple","option","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","trigger","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","key$1","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","getBoundingClientRect","applyTranslation","oldPos","pos","dx","dy","moved","transform","WebkitTransform","transitionDuration","decode","html","decoder","decodeAttr","shouldDecodeNewlines","re","encodedAttrWithNewLines","encodedAttr","decodingMap","parseHTML","advance","parseEndTag","lowerCasedTagName","stack","lowerCasedTag","lastTag","expectHTML","isUnaryTag$$1","isUnaryTag","no","canBeLeftOpenTag$$1","canBeLeftOpenTag","isPlainTextElement","stackedTag","reStackedTag","reCache","RegExp","endTagLength","rest","all","endTag","chars","textEnd","comment","commentEnd","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","startTagOpen","attr","startTagClose","attribute","unarySlash","isNonPhrasingTag","unary","IS_REGEX_CAPTURING_BROKEN","rest$1","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokens","lastIndex","exec","parse","template","endPre","pre","inVPre","platformIsPreTag","inPre","warn$2","platformGetTagNamespace","platformMustUseProp","isPreTag","preTransforms","transforms","postTransforms","root","currentParent","preserveWhitespace","guardIESVGBug","makeAttrsMap","isForbiddenTag","forbidden","processPre","processRawAttrs","processFor","processIf","processOnce","processKey","plain","processRef","processSlot","processComponent","i$1","processAttrs","if","elseif","else","addIfCondition","block","processIfConditions","slotScope","slotTarget","i$2","lastNode","isTextTag","decodeHTMLCached","checkInFor","inMatch","forAliasRE","for","alias","iteratorMatch","forIteratorRE","iterator1","iterator2","findPrevElement","condition","ifConditions","slotName","isProp","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","onRE","argMatch","argRE","ieNSBug","ieNSPrefix","optimize","isStaticKey","genStaticKeysCached","staticKeys","isPlatformReservedTag","markStatic$1","markStaticRoots","genStaticKeys$1","static","staticInFor","staticRoot","walkThroughConditionsBlocks","conditionBlocks","isBuiltInTag","isDirectChildOfTemplateFor","genHandlers","genHandler","isMethodPath","simplePathRE","isFunctionExpression","fnExpRE","genModifierCode","modifierCode","genKeyFilter","genFilterCode","keyVal","bind$1","wrapData","generate","ast","prevStaticRenderFns","currentStaticRenderFns","prevOnceCount","onceCount","currentOptions","warn$3","transforms$1","dataGenFns","platformDirectives$1","isPlatformReservedTag$1","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData","genChildren","genIfConditions","conditions","genTernaryExp","shift","genDirectives","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","baseDirectives","inlineRenderFns","genScopedSlot","genForScopedSlot","scope","checkSkip","el$1","getNormalizationType","genNode","needsNormalization","maybeComponent","genText","transformSpecialNewlines","bind$$1","componentName","baseCompile","makeFunction","errors","transformNode","classBinding","genData$1","transformNode$1","styleBinding","genData$2","getOuterHTML","outerHTML","container","cloneNode","camelizeRE","toUpperCase","hyphenateRE","SSR_ATTR","LIFECYCLE_HOOKS","optionMergeStrategies","silent","productionTip","performance","ignoredElements","isReservedAttr","_lifecycleHooks","freeze","hasProto","UA","isEdge","isAndroid","isIOS","_isServer","_Set","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","nextTickHandler","pending","copies","callbacks","timerFunc","logError","catch","counter","textNode","_resolve","Set","uid","subs","addSub","sub","removeSub","addDep","arrayProto","arrayMethods","method","original","observeArray","arrayKeys","getOwnPropertyNames","isSettingProps","walk","instanceData","defaultData","raw","prototypeAccessors","defineProperties","uid$2","expOrFn","deep","user","active","deps","newDeps","depIds","newDepIds","cleanupDeps","this$1","tmp","teardown","init","$mount","keepAlive","mountedNode","prepatch","insert","destroy","uid$1","_uid","_self","dataDef","propsDef","$set","$delete","hookRE","cbs","prevEl","prevVnode","prevActiveInstance","__patch__","__vue__","$nextTick","_o","_n","_s","_l","_t","_q","_i","_m","_f","_k","_b","_v","_e","_u","patternTypes","KeepAlive","include","exclude","created","destroyed","builtInComponents","configDef","util","defineReactive","delete","ssrContext","version","testEl","acceptValue","svg","math","isHTMLTag","nodeOps","hooks","baseModules","klass","listDelimiter","propertyDelimiter","cssVarRE","importantRE","setProperty","normalizedName","normalize","prefixes","upper","prefixed","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","requestAnimationFrame","activate","platformModules","patch","backend","emptyNodeAt","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","ancestor","addVnodes","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","postpatch","invokeInsertHook","initial","hydrate","hasChildNodes","childrenMatch","isRenderedModule","isInitialPatch","isRealElement","hasAttribute","oldElm","parentElm$1","vmodel","model$1","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","beforeUpdate","updated","hasMove","body","offsetHeight","propertyName","_hasMove","clone","platformComponents","content","encoded","div","singleAttrIdentifier","singleAttrAssign","singleAttrValues","ncname","qnameCapture","&lt;","&gt;","&quot;","&amp;","&#10;","regexEscapeRE","open","close","esc","tab","space","up","right","down","genGuard","stop","prevent","self","ctrl","alt","meta","middle","cloak","klass$1","style$1","modules$1","directives$1","baseOptions","reduce","ref$1","compile","finalOptions","tips","tip$$1","compiled","compileToFunctions","functionCompileCache","fnGenErrors","idToTemplate","mount","argsArray","fun","__WEBPACK_IMPORTED_MODULE_0_mousetrap__","__WEBPACK_IMPORTED_MODULE_0_mousetrap___default","__WEBPACK_IMPORTED_MODULE_1__node_modules_mousetrap_plugins_pause_mousetrap_pause_js__","__WEBPACK_IMPORTED_MODULE_2__utils_db_js__","__WEBPACK_IMPORTED_MODULE_3__utils_utils_js__","__WEBPACK_IMPORTED_MODULE_4__components_Panel_vue__","__WEBPACK_IMPORTED_MODULE_4__components_Panel_vue___default","__WEBPACK_IMPORTED_MODULE_5__components_Overlay_vue__","__WEBPACK_IMPORTED_MODULE_5__components_Overlay_vue___default","db","mousetrap","main","panel","enabled","currentPane","visible","minimized","horizontalGrid","width","columns","gutter","opacity","verticalGrid","rulers","image","scale","difference","lock","position","beforeCreate","getProps","getImage","imageObject","chrome","extension","onMessage","addListener","sender","sendResponse","enable","disable","reloadBindings","mounted","_this2","runtime","sendMessage","response","setProps","setImage","pause","detach","unpause","attach","handleImageChange","handleDisableClick","bindKeyboard","_this3","instance","reset","keyString","keyStringWithShift","_this4","defaultBindings","minimize","toggle","resetPosition","storage","isolatorElement","contentWindow","Panel","Overlay","__WEBPACK_IMPORTED_MODULE_0__utils_utils_js__","parentDoc","isolatorDoc","attemptEnable","changeHandler","onUpload","setIsolatorDoc","doc","bindIsolatorDoc","dataTransfer","inputVal","startIncrement","step","ownerDocument","incrementStopHandler","relatedTarget","toElement","nodeName","incrementTimeout","clearTimeout","incrementInterval","testNewVal","min","roundVal","round","__WEBPACK_IMPORTED_MODULE_0__OverlayImage_vue__","__WEBPACK_IMPORTED_MODULE_0__OverlayImage_vue___default","__WEBPACK_IMPORTED_MODULE_1__OverlayGrids_vue__","__WEBPACK_IMPORTED_MODULE_1__OverlayGrids_vue___default","__WEBPACK_IMPORTED_MODULE_2__OverlayRulers_vue__","__WEBPACK_IMPORTED_MODULE_2__OverlayRulers_vue___default","OverlayImage","OverlayGrids","OverlayRulers","horizontalGridStyles","border-spacing","verticalGridStyles","gradientStop","background","background-size","__WEBPACK_IMPORTED_MODULE_0__directives_draggable_js__","imageOuterHeight","getDocumentHeight","imageOuterClasses","pixelParallel-image-no-image","pixelParallel-image-difference","pixelParallel-image-locked","pixelParallel-image-enabled","imageInnerStyles","margin-left","margin-top","imageStyles","handleDragEnd","newPosition","scrollHeight","clientHeight","resizeOverlay","draggable","handleXDragEnd","handleYDragEnd","__WEBPACK_IMPORTED_MODULE_0__styles_panel_fonts_js__","__WEBPACK_IMPORTED_MODULE_1__styles_panel_icons_js__","__WEBPACK_IMPORTED_MODULE_2__styles_panel_js__","__WEBPACK_IMPORTED_MODULE_3__Toggle_vue__","__WEBPACK_IMPORTED_MODULE_3__Toggle_vue___default","__WEBPACK_IMPORTED_MODULE_4__Number_vue__","__WEBPACK_IMPORTED_MODULE_4__Number_vue___default","__WEBPACK_IMPORTED_MODULE_5__UploadButton_vue__","__WEBPACK_IMPORTED_MODULE_5__UploadButton_vue___default","__WEBPACK_IMPORTED_MODULE_6__Droparea_vue__","__WEBPACK_IMPORTED_MODULE_6__Droparea_vue___default","__WEBPACK_IMPORTED_MODULE_7__PasteBox_vue__","__WEBPACK_IMPORTED_MODULE_7__PasteBox_vue___default","__WEBPACK_IMPORTED_MODULE_8__directives_draggable_js__","dragPositions","contentElement","dragging","elementBoundingRect","windowSize","innerWidth","innerHeight","propNameX","propNameY","propValX","propValY","height","handleDragMove","screenX","screenY","handleDragStart","bottom","setCurrentPane","paneKey","handleCloseClick","onDisableClick","onImageChange","handleRulersReset","contentDocument","panelInlineStyles","styleObject","Toggle","UploadButton","Droparea","PasteBox","pasteHandler","onPaste","checked","__WEBPACK_IMPORTED_MODULE_0_vue__","__WEBPACK_IMPORTED_MODULE_0_vue___default","__WEBPACK_IMPORTED_MODULE_1__PixelParallel_vue__","__WEBPACK_IMPORTED_MODULE_1__PixelParallel_vue___default","pixelParallelContainer","_classCallCheck","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_0_pouchdb__","__WEBPACK_IMPORTED_MODULE_0_pouchdb___default","_createClass","descriptor","protoProps","staticProps","DB","dev","auto_compaction","revs_limit","storageGet","rev","promise","_rev","_id","docId","put","attachments","includeAttachments","message","storageSet","_attachments","overlay","content_type","process","useColors","firebug","exception","table","$1","formatArgs","humanize","diff","color","lastC","log","save","namespaces","removeItem","debug","load","NODE_ENV","local","localStorage","colors","formatters","selectColor","abs","createDebug","curr","Date","ms","prevTime","coerce","format","formatter","names","skips","substr","EventEmitter","_maxListeners","isFunction","isNumber","isUndefined","defaultMaxListeners","setMaxListeners","er","listener","newListener","warned","trace","removeListener","fired","removeAllListeners","listenerCount","evlistener","emitter","ctor","superCtor","super_","TempCtor","INTERNAL","resolver","state","PENDING","outcome","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","returnValue","getThen","thenable","onError","onSuccess","tryToUnwrap","tryCatch","status","out","iterable","values","resolveFromAll","outValue","race","REJECTED","FULFILLED","__WEBPACK_AMD_DEFINE_RESULT__","_addEvent","attachEvent","_characterFromEvent","character","fromCharCode","which","shiftKey","_MAP","_KEYCODE_MAP","_modifiersMatch","modifiers1","modifiers2","_eventModifiers","ctrlKey","metaKey","_preventDefault","_stopPropagation","stopPropagation","cancelBubble","_isModifier","_getReverseMap","_REVERSE_MAP","_pickBestAction","action","_keysFromString","combination","_getKeyInfo","_SPECIAL_ALIASES","_SHIFT_MAP","_belongsTo","Mousetrap","targetElement","_resetSequences","doNotReset","activeSequences","_sequenceLevels","_nextExpectedAction","_getMatches","sequenceName","level","_callbacks","seq","deleteCombo","combo","deleteSequence","_fireCallback","sequence","stopCallback","srcElement","_handleKeyEvent","keyCode","_ignoreNextKeyup","handleKey","_resetSequenceTimer","_resetTimer","_bindSequence","_callbackAndReset","isFinal","wrappedCallback","nextAction","_bindSingle","_directMap","_ignoreNextKeypress","_handleKey","maxLevel","processedSequenceCallback","ignoreThisKeypress","_bindMultiple","combinations","8","9","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","45","46","91","93","224","106","107","109","110","111","186","187","188","189","190","191","192","219","220","221","222","~","!","@","#","$","%","^","&","*","(",")","+",":","\"","<",">","?","|","command","return","escape","plus","mod","platform","className","isContentEditable","addKeycodes","documentMousetrap","_originalStopCallback","paused","fmtShort","fmtLong","plural","floor","ceil","long","_interopDefault","ex","isBinaryObject","ArrayBuffer","Blob","cloneArrayBuffer","buff","byteLength","targetArray","Uint8Array","sourceArray","cloneBinaryObject","size","webkitSlice","proto","getPrototypeOf","funcToString","objectCtorString","newObject","toISOString","getArguments","toPromise","usedCB","PouchPromise$1","fulfill","resp","mesg","logApiCall","logArgs","origCallback","responseArgs","adapterFun","_closed","_destroyed","taskqueue","isReady","addTask","failed","mangle","unmangle","Map$1","_store","Set$1","array","pick","identityFunction","formatResultForOpenRevsGet","ok","bulkGet","collapseResultsAndFinish","results","perDocResults","docs","checkDone","numDone","numDocs","gotResult","docIndex","nextBatch","allRequests","upTo","MAX_NUM_CONCURRENT_REQUESTS","batch","processBatch","offset","docIdx","docRequests","requestsById","docOpts","open_revs","request","formatResult","param","requests","ExportedMap","isChromeApp","hasLocalStorage","hasLocal","attachBrowserEvents","onChanged","db_name","dbName","newValue","Changes","_listeners","guardedConsole","randomNumber","maxTimeout","random","defaultBackOff","explainError","PouchError","createError","CustomPouchError","generateErrorFromResponse","UNKNOWN_ERROR","tryFilter","req","BAD_REQUEST","filterChange","hasFilter","query_params","change","filterReturn","include_docs","att","stub","flatten","arrs","f","invalidIdError","INVALID_ID","RESERVED_ID","MISSING_ID","isRemote","_remote","ee","parseDesignDocFunctionName","normalizeDesignDocFunctionName","normalized","parseUri","parser","uri","decodeURIComponent","qName","qParser","$0","$2","scopeEval","upsert","diffFun","docRev","newDoc","tryAndPut","radix","uuid","winningRev","metadata","winningId","winningPos","winningDeleted","toVisit","rev_tree","ids","branches","deleted","traverseRevTree","revs","newCtx","sortByPos","collectLeaves","leaves","isLeaf","acc","reverse","collectConflicts","win","conflicts","leaf","compactTree","revHash","rootToLeaf","paths","history","sortByPos$1","binarySearch","comparator","mid","low","high","insertSorted","pathToTree","numStemmed","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","tree1","tree2","doMerge","dontExpand","restree","branch","t1","t2","candidateParents","trees","parentIdx","elements","elementsLen","stem","depth","stemmedRevs","stemmed","merge","newTree","revExists","splitRev","targetPos","targetId","getTrees","isDeleted","isLocalId","historyNode","historyRev","tryCatchInChangeListener","Changes$2","onDestroy","cancel","complete","onChange","isCancelled","validateChanges","processChange","changeList","changes","_conflicts","compare","yankError","cleanDocs","_deleted","atts","compareByIdThenRev","idCompare","_revisions","computeHeight","edges","prnt","edge","allDocsKeysQuery","api","skip","limit","descending","_allDocs","finalResults","subOpts","$inject_Object_assign","optKey","total_rows","rows","doNextCompaction","_compactionQueue","last_seq","_compact","attachmentNameError","AbstractPouchDB","TaskQueue$1","parseAdapter","adapter","adapters","PouchDB$5","preferredAdapters","prefix","adapterName","use_prefix","prepareForDestruction","onDestroyed","onClosed","onConstructorDestroyed","destructionListeners","_destructionListeners","__opts","prefixedName","_adapter","valid","fail","ready","debugPouch","PouchDB","logs","logId","getFieldFromDoc","parsedField","compare$1","parseField","fieldName","fields","isCombinationalField","field","combinationFields","getKey","getValue$1","mergeAndedSelectors","selectors","selector","matcher","$eq","fieldMatchers","operator","mergeGtGte","mergeLtLte","mergeNe","mergeEq","$gte","$gt","$lte","$lt","$ne","massageSelector","wasAnded","orOrNor","subSelector","pad","padWith","upToLength","padding","targetLength","padLeft","collate","normalizeKey","ai","collationIndex","bi","stringCollate","arrayCollate","objectCollate","Infinity","origKey","toJSON","k","indexify","numToIndexableString","toIndexableString","objKey","SEP","parseNumber","num","originalIdx","neg","numAsString","magAsString","MAGNITUDE_DIGITS","magnitude","MIN_MAGNITUDE","metaStack","lastMetaElement","lastElementIndex","parseIndexableString","parsedNum","parsedStr","arrayElement","objElement","ak","bk","expFormat","toExponential","magForComparison","magString","factor","factorStr","toFixed","createFieldSorter","getFieldValuesAsArray","sorting","aRow","bRow","aFieldValues","bFieldValues","collation","filterInMemoryFields","requestDef","inMemoryFields","row","rowFilter","fieldSorter","isDesignDoc","docFieldValue","matchCominationalSelector","matchSelector","userOperator","userValue","orMatchers","find","matchers","fieldExists","fieldIsNotUndefined","modField","divisor","arrayContainsValue","arrayContainsAllValues","arraySize","regexMatch","typeMatch","matchesSelector","rowsMatched","evalFilter","evalView","validate","filterName","view","shouldFilter","changesHandler$$1","doc_ids","viewName","ddoc","mapFun","views","MISSING_DOC","doChanges","filterFun","applyChangesFilterPlugin","_changesFilterPlugin","parseRevisionInfo","INVALID_REV","makeRevTreeFromRevisions","revisions","revisionIds","parseDoc","newEdits","nRevNum","newRevId","revInfo","_rev_tree","specialKey","reservedWords","DOC_VALIDATION","dataWords","createBlob","properties","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","binaryStringToArrayBuffer","bin","buf","binStringToBluffer","binString","b64ToBluffer","b64","thisAtob","arrayBufferToBinaryString","buffer","binary","bytes","readAsBinaryString","blob","FileReaderSync","readAsArrayBuffer","hasBinaryString","onloadend","blobToBinaryString","blobOrBuffer","blobToBase64","base64","thisBtoa","rawToBase64","sliceBlob","blob$$1","appendBlob","arrayBuffer","appendString","string","appendBinary","binaryMd5","setImmediateShim","loadNextChunk","done","currentChunk","chunkSize","chunks","inputIsString","MD5_CHUNK_SIZE","Md5","stringMd5","parseBase64","BAD_ARG","preprocessString","blobType","asBinary","digest","preprocessBlob","md5","preprocessAttachment","preprocessAttachments","docInfos","docv","overallErr","docInfo","processedAttachment","recv","updateDoc","revLimit","writeDoc","previousWinningRev","previouslyDeleted","REV_CONFLICT","newRev","rev_map","newRevIsDeleted","winningRev$$1","winningRevIsDeleted","delta","rootIsMissing","processDocs","fetchedDocs","tx","overallCallback","insertDoc","resultsIdx","checkAllDocsDone","docsDone","docsToDo","new_edits","idsToDocs","currentDoc","docWritten","nextDoc","safeJsonParse","vuvuzela","safeJsonStringify","json","idbError","evt","IDB_ERROR","encodeMetadata","deletedOrLocal","decodeMetadata","storedObject","decodeDoc","_doc_id_rev","readBlobData","asBlob","fetchAttachmentsIfNecessary","txn","fetchAttachment","attObj","objectStore","ATTACH_STORE","onsuccess","postProcessAttachments","attNames","compactRevs","count","deleteOrphanedAttachments","possiblyOrphanedDigests","attAndSeqStore","IDBKeyRange","bound","attStore","seqStore","BY_SEQ_STORE","ATTACH_AND_SEQ_STORE","openCursor","only","cursor","digestSeq","primaryKey","continue","openTransactionSafely","idb","stores","transaction","idbBulkDocs","dbOpts","startTransaction","DOC_STORE","LOCAL_STORE","META_STORE","txnResult","onabort","ontimeout","oncomplete","docStore","bySeqStore","attachStore","attachAndSeqStore","metaStore","metaDoc","updateDocCountIfReady","verifyAttachments","preconditionErrored","fetchExistingDocs","onAllDocsProcessed","allDocsProcessed","idbProcessDocs","docCount","docCountDelta","numFetched","readMetadata","_meta","verifyAttachment","MISSING_STUB","finish","digests","filename","attErr","isUpdate","writeAttachments","finishDoc","afterPutDoc","revsToDelete","metadataToStore","afterPutMetadata","afterPutDocError","insertAttachmentMappings","putReq","collectResults","attachmentSaved","revpos","saveAttachment","attsAdded","attsToAdd","newAtt","docInfoError","blobSupport","runBatchedCursor","keyRange","batchSize","onBatch","onGetAll","valuesBatch","keysBatch","pseudoCursor","onGetAllKeys","continuePseudoCursor","newKeyRange","lastKey","upperOpen","lowerBound","getAll","getAllKeys","onCursor","useGetAll","createKeyRange","inclusiveEnd","upperBound","idbAllDocs","fetchDocAsynchronously","docIdRevIndex","allDocsInner","batchValues","batchValue","batchKeys","onResultsReady","onTxnComplete","startkey","endkey","inclusive_end","keyRangeError","checkBlobSupport","DETECT_BLOB_SUPPORT_STORE","matchedChrome","matchedEdge","countDocs","tryCode","applyNext","running","enqueueTask","processMetadataAndWinningDoc","winningDoc","lastSeq","filtered","numResults","returnDocs","onBatchDone","winningDocs","metadatas","fetchWinningDocAndMetadata","onGetMetadata","docIdRev","docIds","docIdsToMetadata","continuous","ExportedSet","since","return_docs","objectStores","IdbPouch","thisCallback","createSchema","createObjectStore","keyPath","autoIncrement","createIndex","unique","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","range","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","digestMap","migrateMetadata","decodeMetadataCompat","onGetMetadataSeq","metadataSeq","instanceId","_bulkDocs","reqOpts","_get","_getAttachment","attachId","attachment","blobData","_info","updateSeq","doc_count","update_seq","idb_attachment_format","_changes","_close","cachedDBs","_getRevisionTree","_doCompaction","_getLocal","_putLocal","oldRev","oStore","oldDoc","_removeLocal","_destroy","openReq","openReqList","indexedDB","deleteDatabase","tryStorageOption","ADAPTER_VERSION","onupgradeneeded","migration","migrations","oldVersion","currentTarget","completeSetup","storedMetaDoc","storeMetaDocIfReady","instanceKey","onversionchange","blobSupportPromise","decodeUtf8","hexToInt","charCode","parseHexUtf8","parseHexUtf16","parseHexString","encoding","quote","escapeBlob","unescapeBlob","stringifyDoc","unstringifyDoc","qMarks","select","joiner","where","orderBy","compactRevs$1","deleteOrphans","seqs","sql","ATTACH_AND_SEQ_STORE$1","executeSql","digestsToCheck","nonOrphanedDigests","ATTACH_STORE$1","BY_SEQ_STORE$1","websqlError","errorNameMatch","errorName","errorReason","WSQ_ERROR","getSize","websqlBulkDocs","websqlChanges","_name","cnt","sqlArgs","deletedInt","insertId","dataWritten","fetchSql","attachmentErr","revsToCompact","DOC_STORE$1","metadataStr","params","websqlProcessDocs","userDocs","docInfoErrors","openDatabaseWithOpts","websql","description","openDBSafely","openDB$1","cachedResult","cachedDatabases","fetchAttachmentsIfNecessary$1","attOpts","WebSqlPouch$1","dbCreated","runMigration2","DOC_STORE_WINNINGSEQ_INDEX_SQL","BY_SEQ_STORE_DELETED_INDEX_SQL","runMigration3","LOCAL_STORE$1","doNext","runMigration4","updateRows","doc_id_rev","hex","doc_id","BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL","runMigration5","nextPage","SELECT_DOCS","DOC_STORE_AND_BY_SEQ_JOINER","pageSize","digestSeqs","digestSeqPairs","pair","attachAndRev","ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL","ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL","runMigration6","runMigration7","checkEncoding","onGetInstanceId","idRequests","onGetVersion","dbVersion","META_STORE$1","initSeq","initSeqArgs","ADAPTER_VERSION$1","setupDone","dbid","tasks","nextMigration","fetchVersion","db_version","getMaxSeq","latest$$1","websqlOpts","POUCH_VERSION","openDBResult","readTransaction","theSeq","theDocCount","websql_encoding","latestRev","totalRows","criteria","selectStmt","reportChange","maxSeq","escaped","putLocal","rowsAffected","removeLocal","store","canOpenTestDB","openDatabase","isValidWebSQL","hasLS","localStorageKey","openedTestDB","openDB","WebSQLPouch","_opts","wrappedFetch","wrappedPromise","fetch","fetchRequest","timer","headers","Headers","fetchOptions","credentials","processData","url","fetchResponse","statusCode","abort","xhRequest","xhr","timedout","abortReq","cleanUp","timeoutReq","onprogress","upload","XMLHttpRequest","withCredentials","Accept","responseType","setRequestHeader","readyState","getResponseHeader","responseText","send","ajax$1","hasXhr","defaultBody","ajaxCore$1","missing","res$2","ajax","ua","isSafari","shouldCacheBust","hasArgs","now","pool","promiseFactories","runNext","runNextBatch","thisErr","readAttachmentsAsBlobOrBuffer","encodeDocId","preprocessAttachments$2","hasUrlPrefix","protocol","getHost","password","auth","username","genDBUrl","genUrl","pathDel","host","port","paramsToStr","HttpPouch","ajax$$1","userOpts","reqAjax","ajaxOpts","defaultHeaders","_ajax","ajaxPromise","adapterFun$$1","setup","skipSetup","skip_setup","setupPromise","dbUrl","encodeAttachmentId","attachmentId","nAuth","token","Authorization","uuid$$1","compact","ping","compact_running","interval","doBulkGet","doBulkGetShim","MAX_SIMULTANEOUS_REVS","numBatches","batchNum","supportsBulkGet","supportsBulkGetMap","fetchAttachments","filenames","fetchAllAttachments","docOrDocs","revs_info","docOrId","optsOrRev","getAttachment","removeAttachment","putAttachment","Content-Type","_put","allDocs","start_key","end_key","paramStr","batch_size","CHANGES_BATCH_SIZE","leftToFetch","feed","heartbeat","param_name","lastFetchedSeq","aborted","xhrOpts","fetched","raw_results_length","finished","revsDiff","QueryParseError","captureStackTrace","NotFoundError","BuiltInError","promisedCallback","callbackify","fin","finalPromiseFactory","sequentialize","promiseFactory","that","uniq","theSet","mapToKeysArray","createBuiltInError","sum","jLen","jNum","evalFunctionWithEval","TaskQueue$2","createViewSignature","reduceFun","createView","sourceDB","temporary","localDocName","cachedViews","viewSignature","_cachedViews","promiseForView","diffFunction","fullViewName","depDbs","depDbName","registerDependentDatabase","lastSeqDoc","parseViewName","isGenOne","emitError","mapper","origMap","reducer","builtInReduce","ddocValidator","viewCleanup","isGenOne$1","fileHasChanged","localDoc","remoteDoc","getDocAttachments","getDocAttachmentsFromTargetOrSource","doCheckForLocalAttachments","createBulkGetOpts","diffs","missingRev","getDocs","getAllDocs","bulkGetOpts","bulkGetResponse","bulkGetInfo","resultDocs","hasAttachments","hasConflicts","fetchRevisionOneDocs","getRevisionOneDocs","returnResult","updateCheckpoint","checkpoint","session","session_id","replicator","REPLICATOR","CHECKPOINT_VERSION","CHECKPOINT_HISTORY_SIZE","Checkpointer","compareReplicationLogs","srcDoc","tgtDoc","compareReplicationHistory","sourceHistory","targetHistory","S","sourceRest","T","targetRest","hasSessionId","LOWEST_SEQ","sessionId","isForbiddenError","backOff","retry","back_off_function","backOffSet","current_back_off","STARTING_BACK_OFF","removeBackOffSetter","sortObjectPropertiesByKey","queryParams","generateReplicationId","filterViewName","queryData","md5sum","replicate","initCheckpointer","checkpointer","repId","writeDocs","changedDocs","currentBatch","bulkOpts","bulkDocs","completeReplication","errorsById","errorsNo","doc_write_failures","docs_written","finishBatch","outResult","writingCheckpoint","writeCheckpoint","getChanges","onCheckpointError","getDiffs","getBatchDocs","got","docs_read","startNextBatch","batches","processPendingBatch","abortReplication","pendingBatch","changesOpts","live","changesCompleted","replicationCompleted","fatalError","end_time","onChangesComplete","changesPending","onChangesError","abortChanges","batches_limit","_abortChanges","startChanges","getCheckpoint","start_time","_addedListeners","Replication","toPouch","PouchConstructor","replicateWrapper","replicateRet","sync$1","Sync","pullChange","direction","pushChange","pushDenied","pullDenied","pushPaused","pullPaused","pushActive","pullActive","removeAll","isChange","isDenied","isPaused","isActive","addOneListener","canceled","optsPush","optsPull","pull","success","replication","other","lie","inherits","mangled","Map","species","setItem","getItem","eventFunction","inprogress","notifyLocalWindows","nextSource","nextKey","MISSING_BULK_DOCS","QUERY_PARSE_ERROR","NOT_AN_OBJECT","hasName","newPromise","post","createAttachment","prevrevpos","was_delete","addToMissing","revId","processDoc","missingForId","missingObj","compactDocument","maxHeight","revTree","candidates","promises","onComplete","finishOpenRevs","existing","splittedRev","revNo","currentPath","hashIndex","indexOfRev","howMany","_revs_info","incompatibleOpt","_type","attachmentError","dependentDb","dependentDbs","depDB","destroyDb","usePrefix","deletedMap","trueName","execute","eventEmitter","Pouch","destructListeners","addToPreferredAdapters","__defaults","defaults","defaultOpts","PouchAlt","$elemMatch","$exists","$mod","neValue","$in","$nin","$size","$all","$regex","$type","atob","IDBPouch","WebSqlPouch","HttpPouch$1","persistentQueues","tempViewQueue","CHANGES_BATCH_SIZE$1","_sum","_count","_stats","sumsqr","_sumsqr","tryMap","tryReduce","rereduce","output","sortByKeyThenValue","keyCompare","sliceResults","rowToDocId","postprocessAttachments","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","coerceOptions","group_level","checkPositiveInteger","checkQueryParseError","startkeyName","endkeyName","group","optionName","httpQuery","keysAsString","customQuery","_query","customViewCleanup","_viewCleanup","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","getKeyValueDocs","processKeyValueDocs","kvDocsRes","kvDocs","oldKeys","indexableKeysToKeyValues","keyValue","newKeys","kvDoc","metaDocId","defaultMetaDoc","docData","saveKeyValues","listOfDocsToPersist","docsToPersist","getQueue","updateView","updateViewInQueue","mapResults","processNextBatch","currentSeq","createDocIdsToChangesAndEmits","createIndexableKeysToKeyValues","emittedKeyValue","complexKey","reduceView","shouldGroup","groups","lvl","POSITIVE_INFINITY","groupKey","reduceTry","queryView","queryViewInQueue","fetchFromView","viewOpts","expectedKeys","parsedKeyAndDocId","onMapResultsReady","shouldReduce","allDocsRes","docIdsToDocs","fetchPromises","keyStart","keyEnd","httpViewCleanup","localViewCleanup","docsToViews","designDocName","viewsToStatus","ddocName","viewDBNames","statusIsGood","viewDBName","dbsToDelete","destroyPromises","queryPromised","stale","abstractQuery","mapreduce","updateTarget","updateSource","readOnlySource","comparisons","targetDoc","sourceDoc","1","cleanup","_readyCalled","defaultSetTimout","defaultClearTimeout","runTimeout","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","currentQueue","queueIndex","drainQueue","Item","title","browser","argv","versions","off","prependListener","prependOnceListener","cwd","chdir","umask","md5cycle","md5blk","md5blks","md5blk_array","md51","tail","lo","hi","md51_array","subarray","rhex","hex_chr","toUtf8","utf8Str2ArrayBuffer","returnUInt8Array","arrayBuffer2Utf8Str","concatenateArrayBuffers","first","second","hexToBinaryString","SparkMD5","lsw","clamp","begin","contents","_buff","_hash","_finish","getState","setState","hashBinary","_vm","_h","on-image-change","on-disable-click","contenteditable","paste","pixelParallel-panel-minimized","pixelParallel-panel-dragging","frameborder","pixelParallel-panel-content-minimized","on-upload","href","click","$event","on-paste","$$v","arrows","toggle-checked","__c","$$a","$$el","$$c","$$i","pixelParallel-rulers-enabled","mousedown","blur","pixelParallel-overlay-enabled","pixelParallel-grid-horizontal-enabled","pixelParallel-grid-vertical-enabled","locals","newStyles","part","arrayPrefix","objPrefix","numChar","parsedString","lastCh","numConsecutiveSlashes"],"mappings":"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","file":"PixelParallel.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 21);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(70)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction getFileTypeFromBase64string(input) {\n  return input.replace('data:', '').split(';base64')[0];\n}\n\nfunction getBase64FromFile(file) {\n  return new Promise(function (resolve, reject) {\n    var reader = new window.FileReader();\n\n    reader.onload = function () {\n      resolve(reader.result);\n    };\n\n    reader.onerror = function () {\n      return reject;\n    };\n\n    reader.readAsDataURL(file);\n  });\n}\n\nfunction getImageFromPasteEvent(event) {\n  var _this = this;\n\n  return new Promise(function (resolve, reject) {\n    if (!event.clipboardData.items) {\n      var waitInterval = setInterval(function () {\n        if (_this.event.target.children.length > 0) {\n          clearInterval(waitInterval);\n\n          resolve({\n            base64string: _this.event.target.children[0].src,\n            type: getFileTypeFromBase64string(_this.event.target.children[0].src)\n          });\n\n          _this.event.target.innerHTML = '';\n        }\n      }, 1);\n    } else {\n      Array.from(event.clipboardData.items).some(function (item) {\n        if (item.kind === 'file' && (item.type === 'image/png' || item.type === 'image/jpeg')) {\n          var file = item.getAsFile();\n\n          var imageType = item.type;\n\n          getBase64FromFile(file).then(function (result) {\n            resolve({\n              base64string: result,\n              type: imageType\n            });\n          });\n\n          return true;\n        }\n      });\n    }\n  });\n}\n\nfunction getImageFromInputEvent(event) {\n  return new Promise(function (resolve, reject) {\n    if (event.target.files && event.target.files[0]) {\n      getBase64FromFile(event.target.files[0]).then(function (result) {\n        resolve({\n          base64string: result,\n          type: event.target.files[0].type\n        });\n      });\n    } else {\n      reject();\n    }\n  });\n}\n\n/**\r\n * Simple is object check.\r\n * @param item\r\n * @returns {boolean}\r\n */\nfunction isObject(item) {\n  return item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && !Array.isArray(item);\n}\n\n/**\r\n * Deep merge two objects.\r\n * @param target\r\n * @param source\r\n */\nfunction mergeDeep(target, source) {\n  if (isObject(target) && isObject(source)) {\n    for (var key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, _defineProperty({}, key, source[key]));\n      }\n    }\n  }\n  return target;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  getImageFromPasteEvent: getImageFromPasteEvent,\n  getImageFromInputEvent: getImageFromInputEvent,\n  mergeDeep: mergeDeep\n});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  inserted: function inserted(el, bindings) {\n    draggableElement(el, bindings.value);\n  }\n});\n\n/**\r\n * Enables draggable functionality to an element\r\n * @param  {Element} element\r\n * @param  {Object} settings Callbacks\r\n */\nfunction draggableElement(element, settings) {\n  var elementDraggable = false;\n  var startPosition = {\n    left: 0,\n    top: 0\n  };\n  var elementMargin = {\n    left: 0,\n    top: 0\n  };\n\n  var elementInitialMargin = {\n    left: 0,\n    top: 0\n  };\n\n  var mouseUpHandler = function mouseUpHandler(event) {\n    elementDraggable = false;\n    document.removeEventListener('mouseup', mouseUpHandler);\n    document.removeEventListener('mousemove', mouseMoveHandler);\n\n    if ('onDragEnd' in settings) {\n      settings.onDragEnd(elementMargin, event);\n    };\n  };\n\n  var mouseMoveHandler = function mouseMoveHandler(event) {\n    if (elementDraggable) {\n\n      if ('onDragMove' in settings) {\n        settings.onDragMove(event);\n\n        return;\n      };\n\n      if (settings.y) {\n        elementMargin.top = event.pageY - startPosition.top + elementInitialMargin.top;\n        element.style.marginTop = elementMargin.top + 'px';\n      }\n\n      if (settings.x) {\n        elementMargin.left = event.pageX - startPosition.left + elementInitialMargin.left;\n        element.style.marginLeft = elementMargin.left + 'px';\n      }\n    }\n  };\n\n  var mouseDownHandler = function mouseDownHandler(event) {\n    event.preventDefault();\n    elementDraggable = true;\n\n    if ('onDragStart' in settings) {\n      settings.onDragStart(event);\n    };\n\n    if (settings.y) {\n      startPosition.top = event.pageY;\n      elementMargin.top = parseInt(element.style.marginTop || 0);\n      elementInitialMargin.top = elementMargin.top;\n    }\n\n    if (settings.x) {\n      startPosition.left = event.pageX;\n      elementMargin.left = parseInt(element.style.marginLeft || 0);\n      elementInitialMargin.left = elementMargin.left;\n    }\n\n    document.addEventListener('mouseup', mouseUpHandler);\n    document.addEventListener('mousemove', mouseMoveHandler);\n  };\n\n  element.addEventListener('mousedown', mouseDownHandler);\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(64)\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(10),\n  /* template */\n  __webpack_require__(53),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.3.3\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n\n\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (false) {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    } )); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (false) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (false) {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (false) {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdateHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdateHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = {\n  key: 1,\n  ref: 1,\n  slot: 1\n};\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) {\n      if (isReservedProp[key] || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {\n      if (getter === undefined) {\n        warn(\n          (\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (false) {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var result = Object.create(null);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      // return nothing if this is indeed an async component\n      // wait for the callback to trigger parent update.\n      return\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"production\" !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (false\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return this\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.3.3';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (isUndef(value)) {\n    return ''\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  var res = '';\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(value[i])) {\n        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        if (ref.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (false) {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (false\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((isDef(modifiers) && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (false) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (false\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\" !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (false) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (false) {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (false) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"production\" !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (false) {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (false) {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (false\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\" !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    false\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, warn$3)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, warn$3)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (false) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}}\"\n}\n\nfunction genForScopedSlot (key, el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el)) +\n    '})'\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (false) {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (false) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_mousetrap__ = __webpack_require__(37);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_mousetrap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_mousetrap__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_mousetrap_plugins_pause_mousetrap_pause_js__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_mousetrap_plugins_pause_mousetrap_pause_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__node_modules_mousetrap_plugins_pause_mousetrap_pause_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_db_js__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_utils_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_Panel_vue__ = __webpack_require__(49);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_Panel_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__components_Panel_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_Overlay_vue__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_Overlay_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__components_Overlay_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\nvar db = new __WEBPACK_IMPORTED_MODULE_2__utils_db_js__[\"a\" /* default */]();\n\nvar mousetrap = {\n  main: new __WEBPACK_IMPORTED_MODULE_0_mousetrap___default.a(window),\n  panel: null\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'pixelParallel',\n  data: function data() {\n    return {\n      enabled: true,\n      config: {\n        currentPane: 'image',\n        visible: true,\n        minimized: true,\n        horizontalGrid: {\n          enabled: false,\n          width: 960,\n          columns: 12,\n          gutter: 30,\n          opacity: .2\n        },\n        verticalGrid: {\n          enabled: false,\n          gutter: 30,\n          opacity: .1\n\n        },\n        rulers: {\n          enabled: false,\n          x: 10,\n          y: 10\n        },\n        image: {\n          top: 0,\n          left: 0,\n          opacity: .5,\n          scale: 1,\n          difference: false,\n          lock: false,\n          enabled: true\n        },\n        position: {\n          x: {\n            name: 'right',\n            value: .5\n          },\n          y: {\n            name: 'bottom',\n            value: 1\n          }\n        }\n      },\n      image: {\n        base64string: null,\n        type: null\n      }\n    };\n  },\n  beforeCreate: function beforeCreate() {\n    var _this = this;\n\n    db.getProps().then(function (config) {\n      _this.config = __WEBPACK_IMPORTED_MODULE_3__utils_utils_js__[\"a\" /* default */].mergeDeep(_this.config, config);\n    }).catch(function () {\n      // No entry in the db\n      _this.config.minimized = false;\n    });\n\n    db.getImage().then(function (imageObject) {\n      _this.image = imageObject;\n    }).catch(function () {});\n\n    if ('chrome' in window && 'extension' in chrome) {\n      chrome.extension.onMessage.addListener(function (msg, sender, sendResponse) {\n\n        switch (msg) {\n          case 'enable':\n            _this.enable();\n            break;\n\n          case 'disable':\n            _this.disable();\n            break;\n\n          case 'reloadBindings':\n            _this.reloadBindings();\n            break;\n        }\n      });\n    }\n  },\n  mounted: function mounted() {\n    var _this2 = this;\n\n    if ('chrome' in window && 'extension' in chrome) {\n      this.disable();\n      chrome.runtime.sendMessage('isEnabled', function (response) {\n        if (response === true) {\n          _this2.enable();\n        }\n      });\n    } else {\n      this.enable();\n    }\n\n    this.reloadBindings();\n  },\n\n\n  watch: {\n    config: {\n      handler: function handler(newVal) {\n        db.setProps(newVal);\n      },\n\n      deep: true\n    },\n    image: {\n      handler: function handler(newVal) {\n        db.setImage(newVal);\n      }\n    }\n  },\n\n  methods: {\n    disable: function disable() {\n      if (!this.enabled) {\n        return;\n      }\n\n      this.enabled = false;\n\n      if (mousetrap.main) mousetrap.main.pause();\n      if (mousetrap.panel) mousetrap.panel.pause();\n\n      this.$children[0].detach();\n\n      document.body.removeChild(this.$el);\n    },\n    enable: function enable() {\n      if (this.enabled) {\n        return;\n      }\n\n      this.enabled = true;\n\n      if (mousetrap.main) mousetrap.main.unpause();\n      if (mousetrap.panel) mousetrap.panel.unpause();\n\n      document.body.appendChild(this.$el);\n\n      this.$children[0].attach();\n\n      this.reloadBindings();\n    },\n    handleImageChange: function handleImageChange(imageObject) {\n      this.image = imageObject;\n    },\n    handleDisableClick: function handleDisableClick() {\n      if ('chrome' in window && 'runtime' in chrome && 'sendMessage' in chrome.runtime) {\n        chrome.runtime.sendMessage('panelDisabled');\n      }\n\n      this.disable();\n    },\n    bindKeyboard: function bindKeyboard(bindings, element) {\n      var _this3 = this;\n\n      var instance = __WEBPACK_IMPORTED_MODULE_0_mousetrap___default()(element || window);\n\n      if (mousetrap.main) {\n        mousetrap.main.reset();\n      }\n\n      if (mousetrap.panel) {\n        mousetrap.panel.reset();\n      }\n\n      setTimeout(function () {\n        Object.keys(bindings).forEach(function (key) {\n          var keyString = bindings[key].base ? 'ctrl+alt+' + bindings[key].key : bindings[key].key;\n          var keyStringWithShift = bindings[key].base ? 'ctrl+alt+shift+' + bindings[key].key : 'shift+' + bindings[key].key;\n\n          instance.bind(keyString, function (event) {\n            event.preventDefault();\n\n            switch (key) {\n              case 'minimize':\n                _this3.config.minimized = !_this3.config.minimized;\n                break;\n\n              case 'toggle':\n                _this3.config.visible = !_this3.config.visible;\n                break;\n\n              case 'lock':\n                _this3.config.image.lock = !_this3.config.image.lock;\n                break;\n\n              case 'resetPosition':\n                _this3.config.image.top = 0;\n                _this3.config.image.left = 0;\n                break;\n\n              case 'left':\n                _this3.config.image.left -= 1;\n                break;\n\n              case 'right':\n                _this3.config.image.left += 1;\n                break;\n\n              case 'up':\n                _this3.config.image.top -= 1;\n                break;\n\n              case 'down':\n                _this3.config.image.top += 1;\n                break;\n            }\n          });\n\n          if (key === 'left' || key === 'right' || key === 'up' || key === 'down') {\n            instance.bind(keyStringWithShift, function (event) {\n              event.preventDefault();\n\n              switch (key) {\n                case 'left':\n                  _this3.config.image.left -= 10;\n                  break;\n\n                case 'right':\n                  _this3.config.image.left += 10;\n                  break;\n\n                case 'up':\n                  _this3.config.image.top -= 10;\n                  break;\n\n                case 'down':\n                  _this3.config.image.top += 10;\n                  break;\n              }\n            });\n          }\n        });\n\n        if (element) {\n          mousetrap.panel = instance;\n        } else {\n          mousetrap.main = instance;\n        }\n      });\n    },\n    reloadBindings: function reloadBindings() {\n      var _this4 = this;\n\n      var defaultBindings = {\n        minimize: {\n          base: true,\n          key: 'm'\n        },\n        toggle: {\n          base: true,\n          key: 't'\n        },\n        lock: {\n          base: true,\n          key: 'l'\n        },\n        resetPosition: {\n          base: true,\n          key: '0'\n        },\n        left: {\n          base: true,\n          key: 'left'\n        },\n        right: {\n          base: true,\n          key: 'right'\n        },\n        up: {\n          base: true,\n          key: 'up'\n        },\n        down: {\n          base: true,\n          key: 'down'\n        }\n      };\n\n      if (mousetrap.main) {\n        mousetrap.main.reset();\n      }\n\n      if (mousetrap.panel) {\n        mousetrap.panel.reset();\n      }\n\n      if ('chrome' in window && 'storage' in chrome && 'sync' in chrome.storage) {\n        chrome.storage.sync.get(defaultBindings, function (bindings) {\n          _this4.bindKeyboard(bindings);\n\n          if (_this4.$children[0].isolatorElement.contentWindow) {\n            _this4.bindKeyboard(bindings, _this4.$children[0].isolatorElement.contentWindow);\n          }\n        });\n      } else {\n        this.bindKeyboard(defaultBindings);\n\n        if (this.$children[0].isolatorElement.contentWindow) {\n          this.bindKeyboard(defaultBindings, this.$children[0].isolatorElement.contentWindow);\n        }\n      }\n    }\n  },\n\n  components: {\n    Panel: __WEBPACK_IMPORTED_MODULE_4__components_Panel_vue___default.a,\n    Overlay: __WEBPACK_IMPORTED_MODULE_5__components_Overlay_vue___default.a\n  }\n});\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils_js__ = __webpack_require__(3);\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'droparea',\n\n  props: ['title', 'onUpload'],\n\n  data: function data() {\n    return {\n      enabled: false,\n      parentDoc: document,\n      isolatorDoc: null\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.parentDoc.addEventListener('dragenter', function (event) {\n      _this.attemptEnable(event);\n    }, false);\n\n    this.parentDoc.addEventListener('dragleave', function (event) {\n      _this.enabled = false;\n    }, false);\n  },\n\n\n  methods: {\n    changeHandler: function changeHandler(event) {\n      var _this2 = this;\n\n      __WEBPACK_IMPORTED_MODULE_0__utils_utils_js__[\"a\" /* default */].getImageFromInputEvent(event).then(function (result) {\n        _this2.onUpload({\n          base64string: result.base64string,\n          type: result.type\n        });\n      });\n    },\n    setIsolatorDoc: function setIsolatorDoc(doc) {\n      this.isolatorDoc = doc;\n      this.bindIsolatorDoc();\n    },\n    attemptEnable: function attemptEnable(event) {\n      if ('dataTransfer' in event && 'items' in event.dataTransfer && event.dataTransfer.items.length === 1 && (event.dataTransfer.items[0].type === 'image/png' || event.dataTransfer.items[0].type === 'image/jpeg')) {\n        this.enabled = true;\n      }\n    },\n    bindIsolatorDoc: function bindIsolatorDoc() {\n      var _this3 = this;\n\n      this.isolatorDoc.addEventListener('dragenter', function (event) {\n        _this3.attemptEnable(event);\n      }, false);\n\n      this.isolatorDoc.addEventListener('dragover', function (event) {\n        event.preventDefault();\n        _this3.attemptEnable(event);\n      }, false);\n\n      this.isolatorDoc.addEventListener('drop', function (event) {\n        _this3.enabled = false;\n      }, false);\n    }\n  }\n});\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'toggle',\n\n  props: ['title', 'value', 'arrows', 'step', 'min', 'max'],\n\n  computed: {\n    inputVal: {\n      get: function get() {\n        return this.value;\n      },\n      set: function set(val) {\n        this.$emit('input', val);\n      }\n    }\n  },\n\n  methods: {\n    startIncrement: function startIncrement(event, step) {\n      var _this = this;\n\n      var doc = event.target.ownerDocument;\n      var newVal = this.inputVal;\n\n      var incrementStopHandler = function incrementStopHandler(event) {\n        if (event.type === 'mouseout' && (event.relatedTarget || event.toElement) && (event.relatedTarget || event.toElement).nodeName !== 'HTML') {\n          return;\n        }\n\n        if (_this.incrementTimeout) {\n          clearTimeout(_this.incrementTimeout);\n\n          _this.incrementTimeout = null;\n        }\n\n        if (_this.incrementInterval) {\n          clearInterval(_this.incrementInterval);\n\n          _this.incrementInterval = null;\n        }\n\n        doc.removeEventListener('mouseup', incrementStopHandler);\n        doc.removeEventListener('mouseout', incrementStopHandler);\n      };\n\n      var testNewVal = function testNewVal(newVal) {\n        return !(typeof _this.min !== 'undefined' && newVal < _this.min || typeof _this.max !== 'undefined' && newVal > _this.max);\n      };\n\n      var roundVal = function roundVal(val) {\n        return Math.round(val * 100000) / 100000;\n      };\n\n      if (!testNewVal(this.inputVal + step)) {\n        return;\n      }\n\n      this.inputVal = roundVal(this.inputVal + step);\n\n      this.incrementTimeout = setTimeout(function () {\n        _this.incrementInterval = setInterval(function () {\n\n          if (testNewVal(_this.inputVal + step)) {\n            _this.inputVal = roundVal(_this.inputVal + step);\n          }\n        }, 80);\n      }, 150);\n\n      doc.addEventListener('mouseup', incrementStopHandler);\n      doc.addEventListener('mouseout', incrementStopHandler);\n    }\n  }\n});\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__OverlayImage_vue__ = __webpack_require__(47);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__OverlayImage_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__OverlayImage_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__OverlayGrids_vue__ = __webpack_require__(46);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__OverlayGrids_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__OverlayGrids_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__OverlayRulers_vue__ = __webpack_require__(48);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__OverlayRulers_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__OverlayRulers_vue__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'overlay',\n\n  props: ['config', 'image'],\n\n  components: {\n    OverlayImage: __WEBPACK_IMPORTED_MODULE_0__OverlayImage_vue___default.a,\n    OverlayGrids: __WEBPACK_IMPORTED_MODULE_1__OverlayGrids_vue___default.a,\n    OverlayRulers: __WEBPACK_IMPORTED_MODULE_2__OverlayRulers_vue___default.a\n  }\n});\n\n/***/ }),\n/* 14 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'overlay-grids',\n\n  props: ['config'],\n\n  computed: {\n    horizontalGridStyles: function horizontalGridStyles() {\n      var opacity = this.config.horizontalGrid.opacity;\n      var width = parseInt(this.config.horizontalGrid.width) || 0;\n      var gutter = parseInt(this.config.horizontalGrid.gutter) || 0;\n\n      return {\n        'opacity': opacity,\n        'border-spacing': gutter + 'px',\n        'width': '' + (width ? width + gutter * 2 + 'px' : 'calc(100% + ' + gutter * 2 + 'px)')\n      };\n    },\n    verticalGridStyles: function verticalGridStyles() {\n      var opacity = this.config.verticalGrid.opacity;\n      var gutter = Math.max(3, parseInt(this.config.verticalGrid.gutter) || 0);\n      var gradientStop = 100 - 1 / gutter * 100;\n\n      return {\n        'opacity': opacity,\n        'background': 'linear-gradient(to bottom, transparent, transparent ' + gradientStop + '%, blue ' + gradientStop + '%, blue)',\n        'background-size': '100% ' + gutter + 'px'\n      };\n    }\n  }\n});\n\n/***/ }),\n/* 15 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__directives_draggable_js__ = __webpack_require__(4);\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'overlayImage',\n\n  props: ['config', 'image'],\n\n  data: function data() {\n    return {\n      imageOuterHeight: this.getDocumentHeight()\n    };\n  },\n\n\n  computed: {\n    imageOuterClasses: function imageOuterClasses() {\n      return ['pixelParallel-image-outer', {\n        'pixelParallel-image-no-image': !this.image.base64string,\n        'pixelParallel-image-difference': this.config.image.difference,\n        'pixelParallel-image-locked': this.config.image.lock,\n        'pixelParallel-image-enabled': this.config.image.enabled\n      }];\n    },\n    imageInnerStyles: function imageInnerStyles() {\n      return {\n        'margin-left': this.config.image.left + 'px',\n        'margin-top': this.config.image.top + 'px'\n      };\n    },\n    imageStyles: function imageStyles() {\n      return {\n        'transform': 'scale(' + this.config.image.scale + ')',\n        'opacity': this.config.image.opacity\n      };\n    }\n  },\n  methods: {\n    handleDragEnd: function handleDragEnd(newPosition) {\n      this.config.image.top = newPosition.top;\n      this.config.image.left = newPosition.left;\n    },\n    getDocumentHeight: function getDocumentHeight() {\n      var body = document.body;\n      var html = document.documentElement;\n\n      return Math.max(document.documentElement.offsetHeight, body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n    },\n    resizeOverlay: function resizeOverlay() {\n      this.imageOuterHeight = 0;\n      this.imageOuterHeight = this.getDocumentHeight();\n    }\n  },\n  mounted: function mounted() {\n    window.addEventListener('resize', this.resizeOverlay);\n\n    setInterval(this.resizeOverlay, 500);\n  },\n\n  directives: {\n    draggable: __WEBPACK_IMPORTED_MODULE_0__directives_draggable_js__[\"a\" /* default */]\n  }\n\n});\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__directives_draggable_js__ = __webpack_require__(4);\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'overlay-rulers',\n\n  props: ['config'],\n\n  methods: {\n    handleXDragEnd: function handleXDragEnd(newPosition) {\n      this.config.rulers.x = newPosition.top;\n    },\n    handleYDragEnd: function handleYDragEnd(newPosition) {\n      this.config.rulers.y = newPosition.left;\n    }\n  },\n  directives: {\n    draggable: __WEBPACK_IMPORTED_MODULE_0__directives_draggable_js__[\"a\" /* default */]\n  }\n});\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__styles_panel_fonts_js__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__styles_panel_icons_js__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__styles_panel_js__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Toggle_vue__ = __webpack_require__(51);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Toggle_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__Toggle_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Number_vue__ = __webpack_require__(44);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Number_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__Number_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__UploadButton_vue__ = __webpack_require__(52);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__UploadButton_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__UploadButton_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Droparea_vue__ = __webpack_require__(43);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Droparea_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__Droparea_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__PasteBox_vue__ = __webpack_require__(50);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__PasteBox_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__PasteBox_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__directives_draggable_js__ = __webpack_require__(4);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n\nvar dragPositions = {\n  start: {\n    x: 0,\n    y: 0\n  },\n  element: {\n    x: 0,\n    y: 0\n  },\n  last: {\n    x: 0,\n    y: 0\n  },\n  max: {\n    x: 0,\n    y: 0\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'panel',\n\n  props: ['config', 'onImageChange', 'onDisableClick'],\n\n  data: function data() {\n    return {\n      contentElement: null,\n      styleElement: null,\n      isolatorElement: null,\n      dragging: false\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.isolatorElement = this.$el.querySelector('.pixelParallel-panel-isolator');\n    this.contentElement = this.$el.querySelector('.pixelParallel-panel-content');\n    this.styleElement = document.createElement('style');\n\n    this.styleElement.textContent = __WEBPACK_IMPORTED_MODULE_0__styles_panel_fonts_js__[\"a\" /* default */];\n    this.styleElement.textContent += __WEBPACK_IMPORTED_MODULE_1__styles_panel_icons_js__[\"a\" /* default */];\n    this.styleElement.textContent += __WEBPACK_IMPORTED_MODULE_2__styles_panel_js__[\"a\" /* default */];\n\n    this.attach();\n\n    // Fix Firefox issue\n    this.isolatorElement.addEventListener('load', function () {\n      _this.attach();\n    });\n  },\n\n\n  methods: {\n    handleDragEnd: function handleDragEnd(newPosition, event) {\n      var elementBoundingRect = this.$el.getBoundingClientRect();\n      var windowSize = {\n        x: window.innerWidth,\n        y: window.innerHeight\n      };\n\n      var propNameX = null;\n      var propNameY = null;\n      var propValX = 0;\n      var propValY = 0;\n\n      if (dragPositions.last.x < windowSize.x / 2) {\n        propNameX = 'left';\n\n        propValX = dragPositions.last.x / window.innerWidth * 100;\n      } else {\n        propNameX = 'right';\n\n        this.$el.style.left = 'auto';\n        propValX = (windowSize.x - dragPositions.last.x - elementBoundingRect.width) / window.innerWidth * 100;\n      }\n\n      if (dragPositions.last.y < windowSize.y / 2) {\n        propNameY = 'top';\n\n        propValY = dragPositions.last.y / window.innerHeight * 100;\n      } else {\n        propNameY = 'bottom';\n\n        this.$el.style.top = 'auto';\n        propValY = (windowSize.y - dragPositions.last.y - elementBoundingRect.height) / window.innerHeight * 100;\n      }\n\n      this.$el.style.transform = 'none';\n      this.$el.style[propNameX] = propValX + '%';\n      this.$el.style[propNameY] = propValY + '%';\n\n      this.config.position.x.name = propNameX;\n      this.config.position.x.value = propValX;\n      this.config.position.y.name = propNameY;\n      this.config.position.y.value = propValY;\n\n      this.dragging = false;\n    },\n    handleDragMove: function handleDragMove(event) {\n      dragPositions.last.x = Math.min(dragPositions.max.x, Math.max(0, dragPositions.element.x + event.screenX - dragPositions.start.x));\n      dragPositions.last.y = Math.min(dragPositions.max.y, Math.max(0, dragPositions.element.y + event.screenY - dragPositions.start.y));\n\n      this.$el.style.transform = 'translate(' + dragPositions.last.x + 'px, ' + dragPositions.last.y + 'px)';\n    },\n    handleDragStart: function handleDragStart(event) {\n      var elementBoundingRect = this.$el.getBoundingClientRect();\n      dragPositions.start.x = event.screenX;\n      dragPositions.start.y = event.screenY;\n      dragPositions.element.x = elementBoundingRect.left;\n      dragPositions.element.y = elementBoundingRect.top;\n      dragPositions.max.x = window.innerWidth - elementBoundingRect.width;\n      dragPositions.max.y = window.innerHeight - elementBoundingRect.height;\n\n      this.$el.style.left = '0px';\n      this.$el.style.top = '0px';\n      this.$el.style.transform = 'translate(' + dragPositions.element.x + 'px, ' + dragPositions.element.y + 'px)';\n      this.$el.style.right = 'auto';\n      this.$el.style.bottom = 'auto';\n\n      this.dragging = true;\n    },\n    setCurrentPane: function setCurrentPane(paneKey) {\n      this.config.currentPane = paneKey;\n    },\n    handleCloseClick: function handleCloseClick() {\n      this.onDisableClick();\n    },\n    handleImageChange: function handleImageChange(imageObject) {\n      this.onImageChange(imageObject);\n    },\n    handleRulersReset: function handleRulersReset() {\n      this.config.rulers.x = 10;\n      this.config.rulers.y = 10;\n    },\n    detach: function detach() {\n      this.$el.appendChild(this.contentElement);\n      this.$el.appendChild(this.styleElement);\n    },\n    attach: function attach() {\n      this.isolatorElement.contentDocument.body.appendChild(this.contentElement);\n      this.isolatorElement.contentDocument.head.appendChild(this.styleElement);\n\n      this.$children[0].setIsolatorDoc(this.isolatorElement.contentDocument);\n    }\n  },\n  computed: {\n    panelInlineStyles: function panelInlineStyles() {\n      var styleObject = {};\n\n      styleObject[this.config.position.x.name] = this.config.position.x.value + '%';\n      styleObject[this.config.position.y.name] = this.config.position.y.value + '%';\n      styleObject.opacity = 1;\n\n      return styleObject;\n    }\n  },\n  directives: {\n    draggable: __WEBPACK_IMPORTED_MODULE_8__directives_draggable_js__[\"a\" /* default */]\n  },\n  components: {\n    Toggle: __WEBPACK_IMPORTED_MODULE_3__Toggle_vue___default.a,\n    Number: __WEBPACK_IMPORTED_MODULE_4__Number_vue___default.a,\n    UploadButton: __WEBPACK_IMPORTED_MODULE_5__UploadButton_vue___default.a,\n    Droparea: __WEBPACK_IMPORTED_MODULE_6__Droparea_vue___default.a,\n    PasteBox: __WEBPACK_IMPORTED_MODULE_7__PasteBox_vue___default.a\n  }\n});\n\n/***/ }),\n/* 18 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils_js__ = __webpack_require__(3);\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'upload-button',\n\n  props: ['title', 'onPaste'],\n\n  methods: {\n    pasteHandler: function pasteHandler(event) {\n      var _this = this;\n\n      __WEBPACK_IMPORTED_MODULE_0__utils_utils_js__[\"a\" /* default */].getImageFromPasteEvent(event).then(function (result) {\n        _this.onPaste({\n          base64string: result.base64string,\n          type: result.type\n        });\n      });\n    }\n  }\n});\n\n/***/ }),\n/* 19 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'toggle',\n\n  props: ['title', 'action', 'value'],\n\n  computed: {\n    checked: {\n      get: function get() {\n        return this.value;\n      },\n      set: function set(val) {\n        this.$emit('input', val);\n      }\n    }\n  }\n});\n\n/***/ }),\n/* 20 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils_js__ = __webpack_require__(3);\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'upload-button',\n\n  props: ['title', 'onUpload'],\n\n  methods: {\n    changeHandler: function changeHandler(event) {\n      var _this = this;\n\n      __WEBPACK_IMPORTED_MODULE_0__utils_utils_js__[\"a\" /* default */].getImageFromInputEvent(event).then(function (result) {\n        _this.onUpload({\n          base64string: result.base64string,\n          type: result.type\n        });\n      });\n    }\n  }\n});\n\n/***/ }),\n/* 21 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PixelParallel_vue__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PixelParallel_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__PixelParallel_vue__);\n\n\n\nvar pixelParallelContainer = document.querySelector('#pixel-parallel-container');\n\nif (pixelParallelContainer === null) {\n\n  pixelParallelContainer = document.createElement('div');\n  pixelParallelContainer.id = 'pixel-parallel-container';\n\n  document.body.appendChild(pixelParallelContainer);\n\n  new __WEBPACK_IMPORTED_MODULE_0_vue___default.a({\n    el: pixelParallelContainer,\n    render: function render(h) {\n      return h(__WEBPACK_IMPORTED_MODULE_1__PixelParallel_vue___default.a);\n    }\n  });\n}\n\n/***/ }),\n/* 22 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (\"\\n  /* latin */\\n  @font-face {\\n    font-family: 'Roboto';\\n    font-style: normal;\\n    font-weight: 400;\\n    src: local('Roboto'), local('Roboto-Regular'), url(data:application/octet-stream;base64,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) format('woff2');\\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;\\n  }\\n\\n  @font-face {\\n    font-family: 'Roboto';\\n    font-style: normal;\\n    font-weight: 500;\\n    src: local('Roboto Medium'), local('Roboto-Medium'), url(data:application/octet-stream;base64,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) format('woff2');\\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;\\n  }\\n\");\n\n/***/ }),\n/* 23 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (\"\\n  .ico { display: inline-block; vertical-align: middle; background-repeat: no-repeat; background-size: contain; background-position: center center; }\\n\\n  .ico-eye-slash { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAaCAYAAADSbo4CAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4OTg4M0UyQ0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4OTg4M0UyREJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg5ODgzRTJBQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg5ODgzRTJCQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+U11e4gAABLFJREFUeNqsV29IZFUU31FzxP/mv9iiL5qKKZGuOoulKAVZbC1+MRKxdKXCzVBCDcQP6YK1sBEjflm1wLWWCkbZTysIhmu5tpPSfohcNpsRKR11ZpxJc8aZ2+88zrXnc1xn0As/3rxzzz3nd88957w7Z86c/rgIJAarLIRQcNrjFbINbALNgC5YIroQHWUCBuB54CyQBISzYytwAcgmRZ1OtwsHZ3nukUSCHbFAGzDPuw0Kra2tO3DSDOhOejS00w+BtUCOIiMjvRkZGZtJSUn/audSUlKEw+GAfUFkHj8JkWeAHwMRiIuLEwMDA2Jnh3wIMT09fUjHaDQKHp+xvY/YZkhEXgIcbNRXXFw8GxMT46f3hIQEMT8/r3iYmZkRnZ2dnvz8fLeaRFZWlvB4PKRiAxIgywf2ACfwarBE3gQ8HHrr5OTkr6Ojo/tOhoaGFBIgsHtUbphMJhmNy2yzALDQHBLYi+dbxxGhSCgOkpOT76+vrzvJWl1dnRKN+Ph4P+10YmLCfRSJ8vJySeJ34DHI4snw2NjYi0VFRX4m48PzjaOIUMm5SJ6WlvYAieZhgw8TExMXSF5WVqYISktLbwciAQdibm5OEqGmFgEY2VmB0+m0lpSUKLoRERG04ee0RCIBM8mio6P/QiR22dg0Z7yStJmZmWJhYcEFh78EIlJbWytJTPHm3gPu4D2eHSavrKyYUWmKPjb4J556NZEP5PkhAbfZ2CwnGo2bx/WMqKgoYbFYaJ0fKOIjWQ0LC/sa70bVMcROTU3dR/4p61AIV9REPucdb+/t7ZGxP4i9KncajyPS0dEho3GD11wheWNj4whkd9SJuLS09AQqS8nFpqYmqiy9JHIe0VASqbu7m5gYtJ0VvePIKklNTRU4f9m8noaMsA2bG1tbW2uQjWrsfULrwsPDxewsBV68v5+s1dXV92gSoaSyvait6YaGhi+PItLf3y+j0cfqIyRvb2+/xfJLKlO1gJ+juMrz1/aJbG5uvlBRUeHnjKZar9LUemxLS8u2lkROTo7wer1kbI2T8hw5QpSu453ybZ3WspkLsj3k5uY+9Pl8tI5OoORAH0FGf2EwGARHhshc1pBpQOkeIDI+Pi6j0cxqJqAJ7yMsf5vl7wJe7lEWu93u5/muQw0NLxE2m+0HZLLa2bdACqsYqFfIucrKSkniN1oLWRRVC36f4+q5xmu/kWvwgXywuroq28NtICxgi6eSReLdrampUZOxAx8DM1JGuWQ2myWR1zU2TIuLi/TV7uC1go/D7Ha7vbxmAUh85EePyAB3h4eHlc95oAStr6+XJCZ5mR54FtV1Sa/XUxTdqo7r6OnpmRX/j3tAalDXAEzEADc3NjZEW1vbARLovmJ5eZkMUrYV8P3UFqDlO6uqqqZQCA4Vie/Idsh3Vii809fXd+Aj19XVJY1+xWpX5Rx6gyM7O/tnROAnl8v1j4qAnWyd6PKMu8gN6Sg9PV2gSZFhcvIUq5Tn5eW9bLVaN8ThQdH4VObDiW/xvb291wsLC8Xg4KB00KMxdlXlnAh9TxFQ9ZDT+TsBxSGVo7+BOM08XUTOA0+G+v9jn4j8EQRe44xvDGFN0PhPgAEA6WDSgUWIcWAAAAAASUVORK5CYII=); width: 17px; height: 13px; }\\n  a.active .ico-eye-slash { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAaCAYAAADSbo4CAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNTU1Mjc0RUJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNTU1Mjc0RkJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1NTUyNzRDQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1NTUyNzREQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+8eEv7QAABbtJREFUeNqsV3tQVFUcPvexd18IQgSEDYoKmI0gojyySRNEEzCcSglxMDSclAYJHLPUyT9K89U4ND4mRyscEnBKG5pJy5LC1MR1aqyYdCAJJ41EIB6y7O7t+909i8siiMaZ+WbPvfd3zv3Od36/754VQnf/y4a5pQOngJahBNe94qX9isNMYi7wGc0PrAKEoQ6U7/NF44F4IBoIBnwBCWgGGoA0HucLBjtUxj7hz4aFCGmXCywBJg+V8UtROnX9E/oX0d09dk+7eq/4wbaGVprPZd7hSUInMluIt3jLRy90ew70NQgsf6piQHc7V+2BFQkDPgISPB+YdQJ7PUFhz0/QyXqJ+db8ZWcLj3b1icmfprARipYexVCDtqYIOAZcvh9FkoDznIQjKkA6Z9IJmrQ0eVm6kS1+XMd+abKzrWetPRu+7+5wHxw6UmSZE3XU/Qd4G5gEbAFqgHlDVSQD+JiUh/R/fphqbGnqVONWf31be7h+usIm+otEwLr3olWhOI7etjZeYbJzeZugRit/fg0IgUbHsKJs9EsHUySJb4cOe3zpbLbZJ2GUNKmqwaap4aUI6oJwHatutHdwEv1aXLDEkkO1tf0O7AO8Acu+uYasyABRxUQyyJTg3rMDEYng9a88ZBSunFpsigAZmqTu5FX7zxQAJQRa6a7z1tN3I0EZsS5B3ysMrxTaGjY7VO44lGZsnBwoMdwUJZGV43aUJxGFS+VllNn1ExmmEOQCyVkNTGvrVjsp8EaHyn676Wi3XLc/fDci88NkhlVTtwokjuJ3OfkNnNMb1xYoGr1njsGCSmN2B1O89QIlr96dyApgClZkK0kz+kAJInYOSOUZT0bFrrY6WEp5p5fqNLM+DdXD1sRrc5IKa/iWbBIFbaymCua6GWgWZrz7tP4S8o9hgaNRCBvdiYylToiP2BMVKBnRrQdSeKJR++qe5hWpsGAvrVxLMY4qbi0QgBK3MzfieNY+aoQw+1Fv0UrXj/mLuS5ViEg5plCxYmNxjZUGZhJ7t/eUwTusA5HwMwps5RStcKi03qA1AQWYs3nDdGUOieke/9ShzpX1LQ5FQsDCCbI/buW4iJxJHitb6OL9C1YpYl97kMe72ueNk0sHIgIHpYqi7i4swLUVxtxo5QcsgPLpW7fwxeQC1Hl5svI3JS83T2fVbJmpX41SVR3YYQdjFbj1jPvLsK+vLp2k6/IkMe6OeTUB7wBT6WVQaT/8JBF9UvYwD6cP4gEqsDBfsa4oTglAn3agrJdI9IGO6p2JhuJoMERGy0iyz3E7z31vNz6pz4sJkvoQWQurl+6YVxt+36Tkr1lqpu8M5VsRjeUF8SlVKIqhoWKBMVR0HhDe4oVxx9CQ0YX75xm+QyYzKEOuVEz5A/hzMr+idHtJQEGWNEYzr1puXvTybJTrRb4F72FMJXMeBfaSi+MDeQX2EITSJRonuIp9nRWDbGA7vyTN8GPq+F7nf4F/qNYx5/nCOUjoZ142nqyaKn+0Ogpw7wYfm6Elgq9oOb3ENAaGSfbwE7AIMY5eQ/Q8KmJFPsT2SG1P7OYzVnbrdv+jxHMRMts2iwRg32CyRF6C45GcCT0ONRm1Rx83M3fc1oJYpTYvRonjwy9QDmJc06BHRe4fs+ABZSczTWxZVJ9vGoP7ssJYTQ0HN6+RQCNwqaNH/QAkSEUzCLTNDJGqLDlm5kbiCDDDReKe5xEE0qc9A2yPQ8pi1+qoLYtSWJDTvErIuvG7zZVH8IbW0T7i5fRw2ZYTqYvE8WEGH0YH6dcQf/CBjoo0EJMl8uRj/jCvFdGaQp0uP0CrDPcTTxxMMR5+xEvw4yXsaq08kTdjrpb/dWbt7FGzCmOVruP1tuVZOBDRCQ1tJyZu5CFVXy4ykSp+/LqZm9gXQAUv3+E5xa+KUUTAdUnVsNUjpJL7RANefO2B/oioOK4MESlADbDsPsYMGf8JMABPgCmUXqy07wAAAABJRU5ErkJggg==); }\\n\\n  .ico-eye-slash-small { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAWCAYAAADXYyzPAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNTU1Mjc1MkJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNTU1Mjc1M0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1NTUyNzUwQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1NTUyNzUxQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+OJ3L3AAABKJJREFUeNqsVglQlGUY/v6FBXZxggF2l6O4FllTMEZhUeSGAGW6hOFy0KRdjo7JYVCINMOIQQcDWqtpumvMY5ycRqSBDgLByakBPJJJC8HpUtwlNiBjr56X/iVsCZfwn3nme/9vv+99/vderuaFF9linud2VrM9tXVCrIaF3OMWS4xHDHwHfA1sxwf8YM8lRzuVOwFJgBJYBrgDQuAaL9/N4wZQfCeIvYEqoBDwmO+gg4ODRa0q8ocoB25rtWCe/W28gqetpBzH/SGXB5/OXJ/RFSKX/zT7QrQyipNKJOkQKxHzQECwUGI3oBVoBKYEAsHAdCDFYnNZiVqUvfGRGJFIFC8QcH4zQRaLWey6GBJv6vX6vVhbgE9A7m4vsQToAujLv1A/VtS4ZIkrxZQ99OADAk4gYK+89rrl2EfH2aXL389cio+LZS4uLiRqml4+cB3rr0Aa0Alyye2IKTtPACsdHR0/ePaZSqOzs3ONXv87B4sMS0PkrK2t/c/x8XFutgJPDw8WuXoViTdOdfdoSE9GelrmiuXLR0kXPNYKcvF8xOTaaKFQeKxqR0UEkiVNNzr6Df3g6urKLBYLuzI0fPPfClJSkhmUk7in48vOUqzByqhIp6yND/eGh4Uxs9kc6eTk9M5/ESdTGSB5LlSUbwuAonC8v9VysjWPfhwZGRHub2w2m0wmt9mXA/z92TJFKImXmjUHTmItDwwMmOS9l565IeM9mVTKpqamcl5qal4/FzERsZXhYVOwOAriQaAEiTIIyylmbHJy0iYR709NsYqVY2P6GnJ34aaCHLIaMMHSrb5+vuf/1h3+/FzEh2Gl/sK3F1cNDQ9T1qgRFxNWi5vbXa/OlRzkRl9fHxK7cPZHrJvc3d3fhdfKIU9/LPaVfX39CiSeae2aaCXv2VuIr8XFrjsCV7JDh4/64sI9Mx1E5l0L990SWyQfS05KJNECVAANQMeTj5cG8d1rEDoUfLIKUWpHKU/wrLBJroT4uF1JiQmTBoNBDOtPYyuS9i8ODJhysrOqKXtnNQsGT5D4IQioVV5Fje/GvQJKUuxRuDqpPOEVTczaNVmQtcARG2IcJqvzEDcksMUTW90UO+rTjc2abq1OZ9MsgGqgB4Nhs0QiqTUajZ21dfVU0KcAqaenZ4OqaGs+39cftYbApoGA/ARiUVWQn8fQnehwPXAZXnjTeiYxIZ6hvklswvmrIL2u0+kKUEoudfX7/FA+NO7Gke1VT5SVFPJNaTvfzeYfi1BWgSze29HZZent7ePggekP9PLyYqXFKqrbkfZPP1/91Zkzu7B9Lz+1aIKZkVzvY1j87C2TVfCW0pDZZ9d0giUNID+3ISP94NDQsJdWq53eT/2nWewGKQ0RNX/lPMqwLTcn+7fgoKDNeKfiptiogOMLGosgb4+IuC91YmKih5oXMpuFLg2hn2hovAHE+Ph4t+Tn5m5BP6dR+BRAMTADbwM7gV/+1zzu7z97Fp1HhhIcVChCpfz2DnyUkeoXQ2Q/1i1Wq/nyoXy4suh/ICXFKqojI//aAdLZSfIxcIgSEBhb0H8uav52PCKgDPgMOMfuwPOXAAMAFT2J6mINzK8AAAAASUVORK5CYII=); width: 15px; height: 11px; }\\n  a.active .ico-eye-slash-small,\\n  a:hover .ico-eye-slash-small { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAWCAYAAADXYyzPAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyRDhDQjlEQUJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyRDhDQjlEQkJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJEOENCOUQ4QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJEOENCOUQ5QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+rDemogAABJxJREFUeNqsVg1MVVUc/597373vvstLka8VCAoSkgoxgqeow2LxSM1a0/BrBi4/0mYWw8lYjjTdomnWWLoS/GKGtDZDCaYzDVLmtNqKlpVJ5gyFSKUejwfv4/Y7l/sYBCGEZ/vtfNxz/r/z/zyXRe/5m0bTmtZZKWavQ0LvHsk5NlpiNBX4CbgEbMIFrg7nkGmYwmXgCcAGxAOBgAS0GOPxBtqANfeD+EGgAFgBBA15M5G044vUKAwnAffUWhhi/VVDwEY/qcioMz1SbHgz3Vz/eJT4e98DuQkyiwsSsjDcDJ9PBISREo8FaoDdQLdJoMt8McjCfLWLVUuJXZkZqLB0gbEI/4FxCqP1ydzy5Lrp0IrRVwO1IA8cLnEoUA9kMaIzMN3uEJVxn9LODEWAxpRZ4dQ2nHLRmd88vYdeSZFpjJnxYcms8o5W9LcAO1AH8tB7EfPoPAEkKiYq/3Gt1fOATFtvOTQGbd1zokTadr6rq9Wpsb4CogMFWj5V17bt/a+7S7icotnm+U/Hmu5wWaJANSBXhyLmpp1uMdEnjS9akySB7Nfata/4h2ALI59G1HDD6/q3gM0zZDL1SNm262L3S+hjchIk+b1M5ZtnHzaR10cpqsQO/BdxBk8DgdH3l3IDJuCWCZiXFda5lvCPV277JNvBDp/bp/u/t9nCRbJH64nx8+zyjs/Q56VFiE6uNcyStX2O+VB8sEBOt5Y9/VDH3MGIORE9F2fqxu1SMTwCrEWgNCFNuM/ojkvrFw/c3oVp5l7Fmx3aVm7u8gWWbK414A2Q2MpHw8TGHtnSG4MRH4W5/jp+xZN8odn7C+ar4Rcveu0hq7BnsOB4BmZMDNOP12PvDfTLI8cIB2G1PIz1y2LdVnnZPRmB512dJNkMy/Yjbnk5Wa70+IhW1bjCcSDSv2FqiLAd5uvnW7OI2jhD1xaep3we9MDZz5eq0Ub1aoKMyUawSki1j3mccHEDgmtjqrwlzyY74Q8V2jdgKYWv11z1ePdmKYU8ev1tZaJM4VZd0Ecg4KXy+snFahHOLeNBijXurjqenrBKyZokeSHGfwKVA0omNregwC+RRVZVfKErGGLPQZ0iLijtcMc5l5G2SK3eYsHdzHucO4b+iy4v1U0rdSgYf8k1jQkUdn66UM0x6nqu3wUDCgjIT8AXBQfmW2ismfHNb/Gg7vRQqWbseS1VJqusa/su9l8Haeu1dt+ydy52K1M+dEQgfXbgmwPRXnB6qbrCKEqbjGo29LMIYfmI4mII0yp+cDPksH7B2HEC1WarhHT7Y0dD12Nl37q3YPkRXMOm9bxgPlS3w1WL1OYpIUK+oSl/ZN4e9nsMcjsIj9iPOkOa7vr0tdJ5CmVM0L2zHtrG8rw1tjciDU9+8JRyd9Z48QXM44DbwCrg2IieRQg+9Xy89GRbp3Ye0wBEtp+UPxr7gJnTQoXqsnmWnFCV8adwAw94rjWwH3gduPm//0BQeQLmTjI1ZU40hfEqhLYAl6o2rLKrr9ZG+pQCv476D6QmW+Vvsf8pOusnNVoVUMEDEGgf0T+XpmnD2WcB1gGnge/oPrR/BBgAJ8Z/uPblQXYAAAAASUVORK5CYII=); }\\n\\n  .ico-minimize { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAECAYAAACHtL/sAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNTU1Mjc1NkJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNzg5RUNEMEJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1NTUyNzU0QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1NTUyNzU1QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+scZqyQAAACJJREFUeNpibGxunclAAWAB4jRKDGBioBCAXDCLEgMAAgwAnRQDLht0cb4AAAAASUVORK5CYII=); width: 8px; height: 2px; }\\n  a.active .ico-minimize,\\n  a:hover .ico-minimize {  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAECAYAAACHtL/sAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyRDhDQjlENkJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyRDhDQjlEN0JBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE3ODlFQ0Q5QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE3ODlFQ0RBQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+0GRmFwAAACJJREFUeNpiVJz2eSYDBYAFiNMoMYCJgUIAcsEsSgwACDAAvYgDTxaOGksAAAAASUVORK5CYII=); }\\n\\n  .ico-maximize { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyRDhDQjlERUJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyRDhDQjlERkJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJEOENCOURDQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJEOENCOUREQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+IjlJQwAAADJJREFUeNpinDVn7n8GKgImBiqDwW8gCxYxRhLN+D/Cw3DUwFEDB2te/j8ahiQBgAADAF83BP0ZNeZfAAAAAElFTkSuQmCC); width: 10px; height: 10px; }\\n  a.active .ico-maximize,\\n  a:hover .ico-maximize { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBRTdEOTYyOUJBOUExMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBRTdEOTYyQUJBOUExMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJEOENCOUUwQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkFFN0Q5NjI4QkE5QTExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+rpUt2wAAADJJREFUeNpiVJz2+T8DFQETA5XB4DeQBYsYI4lm/B/hYThq4KiBgzUv/x8NQ5IAQIABAFs3BNTp9ScaAAAAAElFTkSuQmCC); }\\n\\n  .ico-close { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAUCAYAAACJfM0wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxNzg5RUNEM0JBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNzg5RUNENEJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE3ODlFQ0QxQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE3ODlFQ0QyQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+0WmeEwAAAPtJREFUeNqU1UsKwjAQBuAY3HQnnsGz1F3VleJFfOxERE9SdaXSnXcRTyB01W6dyASGsUlmAj80TfoxNEPb2+0PhowF5AFpjX5kkAJydRNLFtaQM+SGm7ToHXKBrCg8hxzxeqzEPZrj/OQ8D1eQJ9ksxTlq0Kk83EBmSjyEOqeh71iDR1F+eFI8iXbBKXwoQUNwDH9J0BgcwgcSNAV7fAmp2f0a7zehB62gT0tWqa+8jPW5VTY/rTzH9UwDh1pqxN55ELcKdAr5dBxoJ24VaBvplj/cKlEjxSk8EaIpvOCw+0hvhWgI3/g/SJ9tdB/7t/L35PECi/uNrwADAPh2YLGNv80DAAAAAElFTkSuQmCC); width: 11px; height: 10px; }\\n  a.active .ico-close,\\n  a:hover .ico-close { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAUCAYAAACJfM0wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxNzg5RUNEN0JBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNzg5RUNEOEJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE3ODlFQ0Q1QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE3ODlFQ0Q2QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Pl14FgAAAPxJREFUeNqU1UsKwjAQBuAY3HQn3kDwLHVXdaV4ER8X0BN4hKorle68i3gCoSC0WyeSgTB2kpnAD02TfgzN0PZGx48JxhJyh7RGPzJIAbm4iQ0WNpAT5Oo3adEb5AxZh/ACsvfXEyWOaO7nB+chXEEewWYpTlHjnQrhBjJX4hzqnCZ8xxo8itLDk+JJtAtO4UMJysEx/ClBYzCHDyRoCkZ8BanJ/drfb7gHraBPS1IpVl7G+twqmz+sPPfrmQbmWmpM3jmLWwU6g7w7DrQTtwq0jXTLH26VqJHiITwVoim8oLD7SO+EKIdv8Q/SJxvdx/6l/D0hXvjifuMrwADc6WDSaVwquAAAAABJRU5ErkJggg==); }\\n\\n  .ico-lock { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAcCAYAAAB/E6/TAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4OTg4M0UzMEJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4OTg4M0UzMUJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg5ODgzRTJFQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg5ODgzRTJGQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+ZGIeAgAAAfFJREFUeNpiZCAMZIE4BogdgFgaiFmA+DYQ7wHief/////MQCFgAuI6IP4GxP9x4NdAHAm0jIEQxgXYgHgVHguQ8T8griRkESMOiyYAcT6Mw8jIyGBra8tgZGTE8OvXL4aDBw8yXL16FVk9yMIIoIGrSAkyfSD+C3OxpKTk/0OHDv1HBv/+/fu/YMGC/2xsbHCfcXJyfgXSPKQE3RyYZhYWlv9nzpyBmw/EB4G4H4inAvGV2bNnowRjeHj4TFIsug/TGBYWBrPkGRDbooTV//+Mf/78SVBSUvoHUx8UFPQTKI7VV0xYLJKDMezs7EDUHyD2BcbTYWRFQD7Ixwv4+PiOw8QeP34MSkSRuJIwTjFBQUEQtQ5o6FlcEXrhwoWLMPaPHz9AlAuxFqGDQyTmP0VyLXpPokUc2ASR8xGoiHEDZT6YgK+vL8P79+83Hzly5Boeg0F6DEEMUVFRhpiYmFf9/f0OwARwHZtiFWik/6cSfgoKLWypTh2ImRmoB6R27Nhhgk3Cm4q+AeN37949B/qECV8+ogpgYmKSAFK8pKQ66lg8atGoRQNm0Xcq5yEGYDWPVY5VRkbmFFABxSUCqB1RUVEBq5n5MVpBQI4TkNpLRY+BqngeWGghxxGoqt4KVUAp+AXEXchRwoivFUlNABBgAMOih6y6PH/+AAAAAElFTkSuQmCC); width: 13px; height: 14px; }\\n  a.active .ico-lock { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAcCAYAAAB/E6/TAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDM0E3NkI0QkJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDM0E3NkI0Q0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMzQTc2QjQ5QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMzQTc2QjRBQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+R5SWVwAAAglJREFUeNpiVJz2mYEAkAXiGCB2AGJpIGYB4ttAvAeI593L5CFoAAgw4rGICYhrgLgCiDlxqHkDxHlAy5YTsogJhzgbEK8A4kY8loCACBAvVZr+pZJci7qAOBTubSA2k2JmSNJjZYjRYWVQFULRBpJuBVoWRmrQ6QPxOZgjxLgYGSa7cTCYSjLDFfwH4nU3/zBUHfjB8PsfRIyDheHbjz8M4sBg/ILNIhYsYrkwS5iB5BwvTgYdUSaY+YdBjgB6gS1YncX+zz927coDP8GagJZw+aiw9AKZ6cRa5AxjeCiywCx5DsThwOA5DJMDupwxRIM1fvq53/MeffoHCj6Q7xKAVDEQfyEmjuRgDFC8AMEfIPZFtgQEgPz/qjO+LOBhYzgOE3v+5R8oEUUSmxjgYvzsYIeuAxp6FlckX3vz7yKM/fMvmHIhJdUhg0MMpAFFci16T6JFHIQSA6iIcUOW3HznD8OSq78jgEw9PAZbwBivv/1naDn2U3zexd+awMRyHVs+UgHiG6AUzUAd8AxURgIt+4cedOpUtAQEpBb4cJqQGkdkAX0xpo3I5tPMIiZGBgkgxUtzi8hJ3qMWjVpEG4u+UzkPMbAyMWK16LAED+NpNDmyACvQxDQDNlAbAmvp/ftYLDeo/baXih4DFai/sMURqKreClVAKfgFbbLBo4Tx////dEkMAAEGABHchhTziHgTAAAAAElFTkSuQmCC); }\\n\\n  .ico-color { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAeCAYAAABNChwpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDM0E3NkI0M0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDM0E3NkI0NEJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg5ODgzRTMyQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMzQTc2QjQyQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+HF+mwQAAAyxJREFUeNq0l89rE0EUx2fTiDHEJhIJgaSGUlEUrA1IaTVIaaSH9qD0UE9SoT0oHopQCurB9GD7N0hQPHjxoF5SaSFgRKlSMNLcCorGaCGa/jDWqE3d8ftgt0yXbXa32Q58mGV3Zt53Zue9eSOxOgvnvK7+koW2AXAenAGt4CDYB1ZBHrwFU+AVRMnMxnIIJMFfmrAJPoBh4KTVMcJoda6BNZOGtcyBYzsVsAfcNzIiSZKRiB/gnFUBNPOHegPGYjGeTCb5wsIC39jY4H19fdyEyHXU3VYE3NQOEolE+MzMDNcWMwIIp9P5E3XEjIDjYF3s3NnZyUulkmj3JRgGRzC7KbN7IhgMzpkR8Fjs1NLSwldWVlTDn0CPpn3KysaMx+MXawk4CmRxg83OzqrG6cGv87ssCWhvb/9eS0BCbNzf368afw9823iLJQEOh4P20gVRgEMY7Kw48tDQEFM6XsJqrNoR0WRZZvl8PiG+EwVE1YeGhgbW1dVFj09h/LWdYbVQKLQqYX2LgL1gc5nD4TBzu930eI/ZXIrFIsWZmFaAS2zU2NhI1T+QsVvA2hpFdnZSK6AiNlpeXqbqC5a/YrcAZXJBrYAqjJXUl4uLiyTiF9uFQr8XxaO3CbNikjE9PR3cDQFtbW1UlfW+XRd9trubzg/uNRjPUhxwuVy8XC7TuLf0AlEI7ieLHUZGRibtFDAwMLB5jumeBR0dHW/EDn6/n7KgsB0CKLRns1ky/hvs1xUwNjZ2yuv1buno8Xi+oj5cr4DBwUF19o9q5gPj4+MvdGI4bZorlOftREBTUxOHV5FxGURrCsDL8Ojo6J9tBvsI7oAeZVXSRsZpRXO5nDr7B6ZyQqRblxOJhJmcrybwedH4Z3DAdFaMj5OpVIqHQqEdGafjHHFfNb4KTlhKy/FRArfht/LExAQPBAKmdjpOUZ5Op8UUrrCdccLwZkQ+i+putVoNZTIZhiyJzc/Ps6WlJVapVJjP52PNzc0sGo2y3t5ehgRW7P4EXAXf6r3/kd/eAEVuXGinPwdxMzcjyeLlki4slKmcVo5UyhPdyv2QPOQdeKbcFU2V/wIMAB8kuOEdlGYQAAAAAElFTkSuQmCC); width: 16px; height: 15px; }\\n  a.active .ico-color { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAeCAYAAABNChwpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDM0E3NkI0N0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDM0E3NkI0OEJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMzQTc2QjQ1QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMzQTc2QjQ2QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+EZEHUwAAA55JREFUeNq0l2lIVFEUx+9zVsdRI83GvaQQLbRcCrRlCikYiRYCESuKMpSkok8VRYKVfupDSCblgvTFghYliUIws7TFjISKpMLUNhU1dVzGmdf/vnkjz2mW95zxwI8Z7tx553/PPffc85jl10aJJ/Y1X+vR/+US5oaAnSAdJIBg4BtTNjaMz27QDh6CFoiyiH0oIyICUeA8OACUYoICikE1hMy4m+zjShw4Bj6AIyKdU4sBN8ALRCduvgIUoAKUAj9XCl1YKmiDiAypAuhzq8Ah+x9SQmWkWK8ijdka0pWnJfpotykUgIc1QMRWKUl4BuQIB8L9GXJ5s5psjJRJznIW0ZT5kAcQsRo50e0uAvGgUDiQtFRG6vZqhM5bQC6IbeqeaRAjwmwh2iUa5o6YCBTx+29N/wAfUpmpJgEqbrep+qNYyeO5CxRn/UY2dV/9RNatHb61ziIQC3YLE+FKhsrmvBUk2zmXbOPTXFI73YJsYWJvi5Fz4Yd9AQY4HyQeWme/OfhZj3mXMwGbhD9kxSlsId7PVzuPzYKn9Y1aCp0JWGv7IkMc1odxq78H563Ei/ZzjE3gy/ocASqwyDao0zLE15qeFcTLNjDB0m3eYC9ALZykVXKpYAZN3hYwbuIOTqK9AKNw0sgkN6kX4Td6W4C/dXE6ewEmDA/YBn+Ps2R4ih0nC2A6P06A1lESvhVWl+bvZt1CCIgP5lz+/U8AnD4STqz9aFqM2h3oTecqHKx11tPV6ygCt3H8Zktra5+ZFD2fOu1NARnL5MRPwW3BO0cC+hJCZK+Ef7j/eeYUPiK84Zy6zUvieppJusMOb0OEp4DPUs6GJlmlRsG8xNcVngrYEysnq6z7XwdGHQoo75h+czhR0SwcM5rYMB+GS9A8iU3srIWisJ1LV9nyu8RlR3Q8RZmTu0YxZVfD/fFRBrrAJXpX8VFRizn3lQZfEmi9VWtAh9uuGO3WwdL26aqrr6fFX/iOzjxWXgXnsUHcOnv4CjjktildeX2s+kSKsuSmQW0rHJJtO67zenRSvPMRkGnv3N2Lydkt0fLJJ9myCzWdJqbyvYkMTrBuM53eogXJSpIWMdvC0TNvoO3AvF5MUIyo8vIZCwlv+2Em7b/M5NOAhQxNsWQCFwvtmCLRutEM10fJuQZWYHdBPvjjyZsRFUGTsACcFN7lzhth8hRcBI1u6wPLSkoz2ibpQRqfUEFAA2jH9I3P8Aa+gRVl/wQYAICSAbXYakIpAAAAAElFTkSuQmCC); }\\n\");\n\n/***/ }),\n/* 24 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (\"\\n  /* ------------------------------------------------------------ *    Pixel Parallel Panel\\n  * ------------------------------------------------------------ */\\n\\n  * { padding: 0; margin: 0; outline: 0; border: 0; box-sizing: border-box; }\\n\\n  body { font-family: Roboto, Arial, Helvetica, sans-serif; font-size: 12px; line-height: 1; color: rgba(0,0,0,.85); overflow: hidden; font-weight: 500; }\\n\\n\\n  /* ------------------------------------------------------------ *    Buttons\\n  * ------------------------------------------------------------ */\\n\\n  .btn { display: inline-block; position: relative; overflow: hidden; background: #2196f3; padding: 0 15px; border-radius: 2px; font-size: 14px; line-height: 32px; color: #fff; text-transform: uppercase; text-decoration: none; text-align: center; cursor: pointer; transition: 200ms; }\\n  .btn:hover { background: #2980b9; }\\n  \\n  .btn-block { display: block; width: 100%; padding-left: 0; padding-right: 0; }\\n\\n  .btn-success { background: #abdc28; }\\n  .btn-success:hover { background: #9ac117; }\\n\\n  .btn-danger { background: #e85128; }\\n  .btn-danger:hover { background: #e04a28; }\\n\\n  .btn[disabled] { background: #ccc; cursor: default; }\\n\\n  .btn-file input { position: absolute; left: 0; top: 0; width: 100%; height: 100%; opacity: 0.01; cursor: pointer; }\\n\\n\\n  /* ------------------------------------------------------------ *    Grid\\n  * ------------------------------------------------------------ */\\n\\n  .row { padding: 10px 15px; }\\n  .row:after { content: ''; line-height: 0; display: table; clear: both; }\\n\\n  .row-head { border-bottom: 1px solid #ebebeb; padding-top: 10px; padding-bottom: 10px; margin-bottom: 10px; }\\n  .row-head-large-gutter { padding-top: 21px; padding-bottom: 21px; }\\n\\n  .col { float: left; padding: 0 5px; display: table; width: 100%; }\\n  .col-1-of-2 { width: 50%; }\\n\\n  .col-1-of-3 { width: 33.33%; }\\n  .col-2-of-3 { width: 66.66%; }\\n\\n  .col-1-of-4 { width: 25%; }\\n  .col-3-of-4 { width: 75%; }\\n\\n  .col-1-of-5 { width: 20%; }\\n  .col-2-of-5 { width: 40%; }\\n  .col-3-of-5 { width: 60%; }\\n  .col-4-of-5 { width: 80%; }\\n\\n  @media (max-width: 372px) {\\n    .row { padding-left: 5px; padding-right: 5px; }\\n  }\\n\\n\\n  /* ------------------------------------------------------------ *    Header\\n  * ------------------------------------------------------------ */\\n\\n  .header { border-bottom: 1px solid #ebebeb; }\\n\\n\\n  /* ------------------------------------------------------------ *    Panel Control\\n  * ------------------------------------------------------------ */\\n  \\n  .panel-control { float: right; padding-right: 10px; }\\n  .panel-control ul { list-style: none; }\\n  .panel-control li { float: left; }\\n  .panel-control li a { display: block; position: relative; height: 48px; width: 30px; line-height: 48px; text-align: center; }\\n  .panel-control li a .ico { position: absolute; top: 50%; left: 50%; margin-top: -6px; margin-left: -5px; transition: 200ms; }\\n  .panel-control li a .ico-minimize { margin-top: 1px; margin-left: -3px; }\\n  .panel-control li a .ico-eye-slash-small { margin-left: -6px; }\\n\\n\\n  /* ------------------------------------------------------------ *    Nav\\n  * ------------------------------------------------------------ */\\n  \\n  .nav { overflow: hidden; margin-bottom: -1px; }\\n  .nav ul { list-style: none outside none; overflow: hidden; }\\n  .nav li { float: left; }\\n  .nav li a { display: block; position: relative; height: 48px; padding: 0 20px; line-height: 50px; color: rgba(0,0,0,.5); font-size: 16px; text-decoration: none; text-transform: uppercase; transition: 200ms; }\\n  .nav li a:after { content: ''; position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); width: 0; height: 2px; background: #2196f3; transition: 200ms; }\\n  .nav li.current a { color: #2196f3; }\\n  .nav li.current a:after { width: 100%; }\\n  .nav li a:hover { color: #2196f3; }\\n\\n  @media (max-width: 372px) {\\n    .nav li a .ad { display: none; }\\n  }\\n\\n\\n  /* ------------------------------------------------------------ *    Number\\n  * ------------------------------------------------------------ */\\n  \\n  .number { display: block; }\\n\\n  .number .number-field { display: block; position: relative; }\\n  \\n  .number .number-arrows { position: absolute; top: 50%; right: 2px; width: 10px; height: 16px; margin-top: -8px; }\\n  .number .number-arrow { position: absolute; font-size: 0; line-height: 0; color: #bdbdbd; cursor: pointer; transition: 200ms; }\\n  .number .number-arrow:nth-child(1) { top: 0; left: 0; }\\n  .number .number-arrow:nth-child(2) { bottom: 0; left: 0; }\\n  .number .number-arrow-up { border-width: 0 5px 5px; border-style: none outset solid; border-left-color: transparent; border-right-color: transparent; }\\n  .number .number-arrow-down { border-width: 5px 5px 0; border-style: solid outset none; border-left-color: transparent; border-right-color: transparent; }\\n  .number .number-arrow:hover { color: #2196f3; }\\n\\n  .number .number-input { display: block; width: 100%; border: 0 none; border-bottom: 2px solid #bdbdbd; font-family: inherit; font-size: 14px; font-weight: inherit; line-height: 30px; color: rgba(0,0,0,.5); transition: 200ms; -moz-appearance: textfield; }\\n  .number .number-input::-webkit-outer-spin-button,\\n  .number .number-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }\\n\\n  .number:active .number-input,\\n  .number .number-input:focus { border-color: #2196f3; outline: 0 none; color: rgba(0,0,0,.85); }\\n\\n  .number .number-arrows + .number-input { padding-right: 20px; }\\n\\n\\n  /* ------------------------------------------------------------ *    Toggle\\n  * ------------------------------------------------------------ */\\n  \\n  .toggle { display: block; cursor: pointer; padding-bottom: 1px; }\\n  .toggle .toggle-checkbox { position: absolute; opacity: 0; z-index: -999; }\\n  \\n  .toggle .toggle-title { display: block; margin-bottom: 10px; }\\n  .toggle .toggle-title a { text-decoration: underline; color: inherit; font-size: .9em; }\\n\\n  .toggle .toggle-main,\\n  .toggle .toggle-handle { transition: 200ms; }\\n\\n  .toggle .toggle-main { display: block; position: relative; width: 40px; height: 14px; border-radius: 100px; background: #898989; }\\n  .toggle .toggle-handle { position: absolute; top: -3px; left: 0; width: 20px; height: 20px; border-radius: 50%; background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,.2); transform: translateX(0%); }\\n\\n  .toggle-checked .toggle-main { background: #90caf9; }\\n  .toggle-checked .toggle-handle { background: #2196f3; transform: translateX(100%); }\\n\\n\\n  /* ------------------------------------------------------------ *    Icon Link\\n  * ------------------------------------------------------------ */\\n\\n  .icon-link-group { margin: 0 -10px; }\\n\\n  .icon-link { display: inline-block; text-decoration: none; color: #000; opacity: .5; padding: 10px; transition: 200ms; font-weight: 400; text-transform: uppercase; }\\n  .icon-link.active,\\n  .icon-link:hover { opacity: 1; }\\n  .icon-link.active { color: #2196f3; }\\n\\n  .icon-link .text { display: inline-block; vertical-align: middle; }\\n  .icon-link .ico { transition: 200ms; margin-right: 5px; }\\n\\n\\n  /* ------------------------------------------------------------ *    Paste Box\\n  * ------------------------------------------------------------ */\\n  \\n  .paste-box { display: inline-block; position: relative; overflow: hidden; height: 32px; width: 100%; font-size: 0; line-height: 0; background: #fff; border: 2px dashed #2196f3; text-align: center; border-radius: 2px; vertical-align: middle; transition: 200ms; }\\n  .paste-box > * { display: none; }\\n  .paste-box:focus { border-style: solid; }\\n  .paste-box:before { content: attr(title); display: block; line-height: 28px; font-size: 14px; text-transform: uppercase; color: #2196f3; }\\n\\n  /* ------------------------------------------------------------ *    Elements Divider\\n  * ------------------------------------------------------------ */\\n  \\n  .elements-divider { display: block; text-align: center; color: #000; text-transform: uppercase; padding: 10px 0; }\\n\\n\\n  /* ------------------------------------------------------------ *    Droparea\\n  * ------------------------------------------------------------ */\\n  \\n  .droparea { display: none; position: absolute; top: 0; left: 0; z-index: 999; width: 100%; height: 100%; background: #fff; }\\n  .droparea:after { content: ''; position: absolute; top: 10px; bottom: 10px; left: 10px; right: 10px; border: 4px dashed #2196f3; border-radius: 4px; }\\n  .droparea input { position: absolute; top: 0; left: 0; z-index: 9; width: 100%; height: 100%; opacity: 0; }\\n  .droparea .droparea-title { position: absolute; top: 50%; left: 0; right: 0; text-align: center; font-size: 26px; line-height: 30px; margin-top: -15px; color: #2196f3; font-weight: normal; }\\n\\n  .droparea.enabled { display: block; }\\n\\n\\n  /* ------------------------------------------------------------ *    States\\n  * ------------------------------------------------------------ */\\n\\n  .panel-control .ico-maximize { opacity: 0; }\\n  \\n  .nav,\\n  .main { transition: 200ms 200ms; }\\n\\n  .pixelParallel-panel-content-minimized .nav,\\n  .pixelParallel-panel-content-minimized .main { opacity: 0; transition: 200ms; }\\n  .pixelParallel-panel-content-minimized .panel-control .ico-minimize { opacity: 0; transition: 200ms 200ms; }\\n  .pixelParallel-panel-content-minimized .panel-control .ico-maximize { opacity: 1; transition: 200ms 200ms; }\\n\");\n\n/***/ }),\n/* 25 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pouchdb__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_pouchdb___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_pouchdb__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar DB = function () {\n  function DB() {\n    _classCallCheck(this, DB);\n\n    this.dev = false;\n\n    this.db = new __WEBPACK_IMPORTED_MODULE_0_pouchdb___default.a('PixelParallel', {\n      auto_compaction: true,\n      revs_limit: 1\n    });\n\n    // this.db.destroy();\n  }\n\n  _createClass(DB, [{\n    key: 'storageSet',\n    value: function storageSet(options) {\n      var _this = this;\n\n      var doc = options.doc;\n\n      return this.storageGet(options, true).then(function (response) {\n        var rev = null;\n        var promise = null;\n\n        if (typeof response !== 'undefined') {\n          rev = response._rev;\n        }\n\n        doc._rev = rev;\n        doc._id = options.docId;\n\n        promise = _this.db.put(doc);\n\n        return promise.catch(function (err) {\n          if (_this.dev) {\n            console.info('Pixel Parallel:', err);\n          }\n        }).then(function () {\n          if (_this.dev) {\n            _this.db.info().then(function (result) {\n              console.info('Pixel Parallel:', 'db-info', result);\n            }).catch(function (err) {\n              if (_this.dev) {\n                console.info('Pixel Parallel:', err);\n              }\n            });\n          }\n        });\n      });\n    }\n  }, {\n    key: 'storageGet',\n    value: function storageGet(options) {\n      var _this2 = this;\n\n      var promise = this.db.get(options.docId, {\n        attachments: !!options.includeAttachments\n      });\n\n      return promise.catch(function (err) {\n        if (err.message !== 'missing') {\n          if (_this2.dev) {\n            console.info('Pixel Parallel:', err);\n          }\n        }\n      });\n    }\n  }, {\n    key: 'setImage',\n    value: function setImage(imageObject) {\n      this.storageSet({\n        docId: 'base64string',\n        doc: {\n          _attachments: {\n            'overlay': {\n              data: imageObject.base64string.split(',').pop(),\n              content_type: imageObject.type\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: 'getImage',\n    value: function getImage() {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this3.storageGet({ docId: 'base64string', includeAttachments: true }).then(function (response) {\n          if (response && '_attachments' in response && 'overlay' in response._attachments && response._attachments.overlay) {\n            var image = response._attachments.overlay;\n\n            resolve({\n              base64string: 'data:' + image.content_type + ';base64,' + image.data,\n              type: image.content_type\n            }, true);\n          } else {\n            reject();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'setProps',\n    value: function setProps(props) {\n      this.storageSet({\n        docId: 'properties',\n        doc: Object.keys(props).filter(function (key) {\n          return !key.match(/^_/);\n        }).reduce(function (obj, key) {\n          obj[key] = props[key];\n          return obj;\n        }, {})\n      });\n    }\n  }, {\n    key: 'getProps',\n    value: function getProps() {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this4.storageGet({ docId: 'properties' }).then(function (response) {\n          if (typeof response !== 'undefined') {\n            resolve(response);\n          } else {\n            reject();\n          }\n        });\n      });\n    }\n  }]);\n\n  return DB;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DB);\n;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \"\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \".pixelParallel-image-outer{visibility:hidden;position:absolute;top:0;left:0;width:100%;overflow:hidden;max-width:100vw;min-height:100vh}.pixelParallel-image-inner{position:absolute;z-index:2147483646;left:50%;top:0;cursor:move;transform:translateX(-50%);transition:opacity .15s}.pixelParallel-image-inner img{width:auto;height:auto;max-width:none;max-height:none;vertical-align:top;margin:0;padding:0;position:relative;transform-origin:50% 0;top:-1px;border:1px dashed #333}.pixelParallel-image-inner img:not([src]),.pixelParallel-image-inner img[src=\\\"\\\"]{visibility:hidden}.pixelParallel-image-enabled{visibility:visible}.pixelParallel-image-difference{mix-blend-mode:difference}.pixelParallel-image-difference img{opacity:1!important}.pixelParallel-image-locked,.pixelParallel-image-no-image{pointer-events:none}.pixelParallel-image-locked .pixelParallel-image-inner img{top:0;border:0 none}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \".pixelParallel-panel[data-v-54cb82b4]{position:fixed;right:10px;bottom:10px;z-index:2147483647;width:375px;height:265px;transform:translate(0);background:#fff;transition:width .2s ease-out,height .2s ease-out;will-change:top,left,width,height,transform;opacity:0}.pixelParallel-panel-inner[data-v-54cb82b4]{position:relative;overflow:hidden;height:100%;border:1px solid #dddedf;box-shadow:0 2px 10px rgba(0,0,0,.1);box-sizing:border-box}.pixelParallel-panel-handle[data-v-54cb82b4]{position:absolute;top:-10px;right:-10px;z-index:3;width:20px;height:20px;background:red;transform:rotate(45deg);background:linear-gradient(0deg,transparent,transparent 50%,#ccc 0,#ccc);background-size:100% 2px;cursor:move}.pixelParallel-panel-isolator[data-v-54cb82b4]{border:0;width:100%;height:100%;overflow:hidden;position:relative}.pixelParallel-panel-dragging .pixelParallel-panel-inner[data-v-54cb82b4]{pointer-events:none}.pixelParallel-panel-minimized[data-v-54cb82b4]{width:112px;height:50px;transition:width .2s ease-out .15s,height .2s ease-out .15s}@media (max-width:395px){.pixelParallel-panel[data-v-54cb82b4]{right:0;bottom:0;width:320px}.pixelParallel-panel-minimized[data-v-54cb82b4]{width:112px}}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \".pixelParallel-rulers{position:relative;z-index:2147483646}.pixelParallel-ruler-x,.pixelParallel-ruler-y{display:none;position:fixed;top:0;left:0;z-index:2;background:cyan}.pixelParallel-ruler-x:after,.pixelParallel-ruler-y:after{content:\\\"\\\";position:absolute;top:-8px;left:-8px;right:0;bottom:0;padding:10px}.pixelParallel-ruler-x{right:0;height:1px;cursor:row-resize}.pixelParallel-ruler-y{bottom:0;width:1px;cursor:col-resize}.pixelParallel-rulers-enabled .pixelParallel-ruler-x,.pixelParallel-rulers-enabled .pixelParallel-ruler-y{display:block}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \".pixelParallel-overlay{position:absolute;left:0;top:0;width:100%;text-align:center;white-space:nowrap;display:none}.pixelParallel-overlay-enabled{display:block}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \".pixelParallel-grids{position:relative;z-index:2147483646;pointer-events:none}.pixelParallel-grid-horizontal,.pixelParallel-grid-vertical{position:fixed;z-index:1;pointer-events:none;visibility:hidden}.pixelParallel-grid-horizontal{top:50%;left:50%;display:table;width:100vw;height:200vh;opacity:.5;table-layout:fixed;border-spacing:30px;transform:translate(-50%,-50%)}.pixelParallel-grid-horizontal span{display:table-cell;background:red;height:200vh}.pixelParallel-grid-vertical{top:0;left:0;width:100%;height:100%;background:linear-gradient(180deg,transparent,transparent 90%,blue 0,blue);background-size:100% 10px;opacity:.5}.pixelParallel-grid-horizontal-enabled,.pixelParallel-grid-vertical-enabled{visibility:visible}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(33);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  try {\n    return exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (typeof process !== 'undefined' && 'env' in process) {\n    return __webpack_require__.i({\"NODE_ENV\":\"production\"}).DEBUG;\n  }\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)))\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(39);\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports) {\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar immediate = __webpack_require__(6);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.1\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n\n        // This needs to use a string cause otherwise since 0 is falsey\n        // mousetrap will never fire for numpad 0 pressed as part of a keydown\n        // event.\n        //\n        // @see https://github.com/ccampbell/mousetrap/pull/258\n        _MAP[i + 96] = i.toString();\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n            return Mousetrap;\n        }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\n/**\n * adds a pause and unpause method to Mousetrap\n * this allows you to enable or disable keyboard shortcuts\n * without having to reset Mousetrap and rebind everything\n */\n/* global Mousetrap:true */\n(function(Mousetrap) {\n    var _originalStopCallback = Mousetrap.prototype.stopCallback;\n\n    Mousetrap.prototype.stopCallback = function(e, element, combo) {\n        var self = this;\n\n        if (self.paused) {\n            return true;\n        }\n\n        return _originalStopCallback.call(self, e, element, combo);\n    };\n\n    Mousetrap.prototype.pause = function() {\n        var self = this;\n        self.paused = true;\n    };\n\n    Mousetrap.prototype.unpause = function() {\n        var self = this;\n        self.paused = false;\n    };\n\n    Mousetrap.init();\n}) (Mousetrap);\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\n/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(__webpack_require__(36));\nvar getArguments = _interopDefault(__webpack_require__(9));\nvar events = __webpack_require__(34);\nvar inherits = _interopDefault(__webpack_require__(35));\nvar nextTick = _interopDefault(__webpack_require__(6));\nvar debug = _interopDefault(__webpack_require__(32));\nvar Md5 = _interopDefault(__webpack_require__(42));\nvar vuvuzela = _interopDefault(__webpack_require__(71));\n\n/* istanbul ignore next */\nvar PouchPromise$1 = typeof Promise === 'function' ? Promise : lie;\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new PouchPromise$1(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise$1.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise$1.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise$1(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\ninherits(Changes, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (console !== 'undefined' && method in console) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function (fun) {\n    return fun.name;\n  };\n} else {\n  res = function (fun) {\n    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n  };\n}\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 events.EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* jshint maxlen: false */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise$1(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\n// BEGIN Math.uuid.js\n\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. \n *   // (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\nvar chars = (\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n  'abcdefghijklmnopqrstuvwxyz'\n).split('');\nfunction getValue(radix) {\n  return 0 | Math.random() * radix;\n}\nfunction uuid(len, radix) {\n  radix = radix || chars.length;\n  var out = '';\n  var i = -1;\n\n  if (len) {\n    // Compact form\n    while (++i < len) {\n      out += chars[getValue(radix)];\n    }\n    return out;\n  }\n    // rfc4122, version 4 form\n    // Fill in random data.  At i==19 set the high bits of clock sequence as\n    // per rfc4122, sec. 4.1.5\n  while (++i < 36) {\n    switch (i) {\n      case 8:\n      case 13:\n      case 18:\n      case 23:\n        out += '-';\n        break;\n      case 19:\n        out += chars[(getValue(16) & 0x3) | 0x8];\n        break;\n      default:\n        out += chars[getValue(16)];\n    }\n  }\n\n  return out;\n}\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\ninherits(Changes$2, events.EventEmitter);\n\nfunction tryCatchInChangeListener(self, change) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$2(db, opts, callback) {\n  events.EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change);\n  };\n\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$2.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$2.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$2.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.normalize(opts);\n    if (PouchDB$5._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB$5._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn',\n          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n          'but pouchdb-changes-filter plugin is not installed, so it ' +\n          'was ignored. Please install the plugin to enable filtering.'\n        );\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      callback(err || results[0]);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysQuery(api, opts, callback) {\n  var keys =  ('limit' in opts) ?\n      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  if (opts.descending) {\n    keys.reverse();\n  }\n  if (!keys.length) {\n    return api._allDocs({limit: 0}, callback);\n  }\n  var finalResults = {\n    offset: opts.skip\n  };\n  return PouchPromise$1.all(keys.map(function (key) {\n    var subOpts = $inject_Object_assign({key: key, deleted: 'ok'}, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new PouchPromise$1(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || {key: key, error: 'not_found'});\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, events.EventEmitter);\n\nfunction AbstractPouchDB() {\n  events.EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  if (typeof this._put === 'function' && opts.new_edits !== false) {\n    this._put(doc, opts, cb);\n  } else {\n    this.bulkDocs({docs: [doc]}, opts, yankError(cb));\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev) {\n      addToMissing(id, rev);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev) {\n      if (height[rev] > maxHeight) {\n        candidates.push(rev);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n        revs.push(rev);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise$1.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev) {\n            return rev.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev) {\n          pos--;\n          return {\n            rev: pos + '-' + rev.id,\n            status: rev.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (!isRemote(this)) {\n      return allDocsKeysQuery(this, opts, callback);\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$2(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise$1.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue$1() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue$1.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue$1.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue$1.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue$1.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB$5.adapters;\n  var preferredAdapters = PouchDB$5.preferredAdapters;\n  var prefix = PouchDB$5.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  var destructionListeners = self.constructor._destructionListeners;\n\n  function onDestroyed() {\n    self.removeListener('closed', onClosed);\n    self.constructor.emit('destroyed', self.name);\n  }\n\n  function onConstructorDestroyed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.removeListener('closed', onClosed);\n    self.emit('destroyed');\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    destructionListeners.delete(self.name);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n\n  // in setup.js, the constructor is primed to listen for destroy events\n  if (!destructionListeners.has(self.name)) {\n    destructionListeners.set(self.name, []);\n  }\n  destructionListeners.get(self.name).push(onConstructorDestroyed);\n}\n\ninherits(PouchDB$5, AbstractPouchDB);\nfunction PouchDB$5(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB$5)) {\n    return new PouchDB$5(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB$5.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB$5.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB$5.adapters[opts.adapter] ||\n      !PouchDB$5.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue$1();\n\n  self.adapter = opts.adapter;\n\n  PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB$5.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\nPouchDB$5.adapters = {};\nPouchDB$5.preferredAdapters = [];\n\nPouchDB$5.prefix = '_pouch_';\n\nvar eventEmitter = new events.EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n    if (typeof events.EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    destructListeners.get(name).forEach(function (callback) {\n      callback();\n    });\n    destructListeners.delete(name);\n  });\n}\n\nsetUpEventEmitter(PouchDB$5);\n\nPouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB$5.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB$5.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB$5.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB$5);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \\\"' + obj + '\\\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB$5.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB$5.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB$5;\n};\n\nPouchDB$5.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB$5.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB$5);\n\n  PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();\n  Object.keys(PouchDB$5).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB$5[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.2.0\";\n\nfunction debugPouch(PouchDB) {\n  PouchDB.debug = debug;\n  var logs = {};\n  /* istanbul ignore next */\n  PouchDB.on('debug', function (args) {\n    // first argument is log identifier\n    var logId = args[0];\n    // rest should be passed verbatim to debug module\n    var logArgs = args.slice(1);\n    if (!logs[logId]) {\n      logs[logId] = debug('pouchdb:' + logId);\n    }\n    logs[logId].apply(null, logArgs);\n  });\n}\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue$1(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue$1(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    if (isDesignDoc(doc)) {\n      return false;\n    }\n\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction isDesignDoc(doc) {\n  return /^_design\\//.test(doc._id);\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw 'Selector error: expected a JSON object';\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler$$1, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler$$1.db);\n}\n\nfunction filter(changesHandler$$1, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler$$1.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler$$1.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler$$1.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler$$1.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler$$1.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler$$1.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler$$1.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(debugPouch);\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(applyChangesFilterPlugin);\n\nPouchDB$5.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev) {\n  if (!/^\\d+\\-./.test(rev)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev.indexOf('-');\n  var left = rev.substring(0, idx);\n  var right = rev.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = uuid(32, 16).toLowerCase();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob$$1, start, end) {\n  if (blob$$1.webkitSlice) {\n    return blob$$1.webkitSlice(start, end);\n  }\n  return blob$$1.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob$$1, start, end, callback) {\n  if (start > 0 || end < blob$$1.size) {\n    // only slice blob if we really need to\n    blob$$1 = sliceBlob(blob$$1, start, end);\n  }\n  readAsArrayBuffer(blob$$1, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise$1.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise$1.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise$1(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler$$1 = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler$$1.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n  //    perhaps they are filtering on a per-doc basis)\n  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n  var keyRangeError = keyRange && keyRange.error;\n  if (keyRangeError && !(keyRangeError.name === \"DataError\" &&\n      keyRangeError.code === 0)) {\n    // DataError with error code 0 indicates start is less than end, so\n    // can just do an empty query. Else need to throw\n    return callback(createError(IDB_ERROR,\n      keyRangeError.name, keyRangeError.message));\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (opts.deleted === 'ok') {\n      results.push(row);\n      // deleted docs are okay with \"keys\" requests\n      if (deleted) {\n        row.value.deleted = true;\n        row.doc = null;\n      } else if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    } else if (!deleted && skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    callback(null, {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    });\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise$1(function (resolve) {\n    var blob$$1 = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n// before calling the next one. This works around IE/Edge race conditions in IDB.\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler$$1.addListener(dbName, id, api, opts);\n    changesHandler$$1.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler$$1.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n  var returnDocs;\n  if ('return_docs' in opts) {\n    returnDocs = opts.return_docs;\n  } else if ('returnDocs' in opts) {\n    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n    returnDocs = opts.returnDocs;\n  } else {\n    returnDocs = true;\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return opts.complete(filtered);\n      }\n\n      if (filtered) {\n        numResults++;\n        if (returnDocs) {\n          results.push(change);\n        }\n        // process the attachment immediately\n        // for the benefit of live listeners\n        if (opts.attachments && opts.include_docs) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              opts.onChange(change);\n            });\n          });\n        } else {\n          opts.onChange(change);\n        }\n      }\n    }\n\n    function onBatchDone() {\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        processMetadataAndWinningDoc(metadata, winningDoc);\n      }\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev;\n      if (!opts.rev) {\n        rev = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler$$1.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // some outdated implementations of IDB that appear on Samsung\n  // and HTC Android devices <4.4 are missing IDBKeyRange\n  return !isSafari && typeof indexedDB !== 'undefined' &&\n    typeof IDBKeyRange !== 'undefined';\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch (err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nvar IDBPouch = function (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n};\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new ExportedSet();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^\\(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      var rev = docInfo.metadata.rev;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev$$1, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: rev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new ExportedMap();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB$1(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = $inject_Object_assign(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch$1(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = $inject_Object_assign({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB$1(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  function getMaxSeq(tx, callback) {\n    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n    tx.executeSql(sql, [], function (tx, res) {\n      var updateSeq = res.rows.item(0).seq || 0;\n      callback(updateSeq);\n    });\n  }\n\n  function countDocs(tx, callback) {\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      callback(result.rows.item(0).num);\n    });\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    var seq;\n    var docCount;\n    db.readTransaction(function (tx) {\n      getMaxSeq(tx, function (theSeq) {\n        seq = theSeq;\n      });\n      countDocs(tx, function (theDocCount) {\n        docCount = theDocCount;\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: seq,\n        websql_encoding: encoding\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  function latest$$1(tx, id, rev, callback, finish) {\n    var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n    var sqlArgs = [id];\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var err = createError(MISSING_DOC, 'missing');\n        return finish(err);\n      }\n      var item = results.rows.item(0);\n      var metadata = safeJsonParse(item.metadata);\n      callback(latest(rev, metadata));\n    });\n  }\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish(err) {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n\n    if (!opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    } else if (opts.latest) {\n      latest$$1(tx, id, opts.rev, function (latestRev) {\n        opts.latest = false;\n        opts.rev = latestRev;\n        api._get(id, opts, callback);\n      }, finish);\n      return;\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    }\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var missingErr = createError(MISSING_DOC, 'missing');\n        return finish(missingErr);\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        var deletedErr = createError(MISSING_DOC, 'deleted');\n        return finish(deletedErr);\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n\n    var sqlArgs = [];\n    var criteria = [];\n\n    if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (opts.deleted !== 'ok') {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n      // count the docs in parallel to other operations\n      countDocs(tx, function (docCount) {\n        totalRows = docCount;\n      });\n\n      if (limit === 0) {\n        return;\n      }\n\n      // do a single query to fetch the documents\n      var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        criteria,\n        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n        );\n      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var item = result.rows.item(i);\n          var metadata = safeJsonParse(item.metadata);\n          var id = metadata.id;\n          var data = unstringifyDoc(item.data, id, item.rev);\n          var winningRev$$1 = data._rev;\n          var doc = {\n            id: id,\n            key: id,\n            value: {rev: winningRev$$1}\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev$$1;\n            if (opts.conflicts) {\n              var conflicts = collectConflicts(metadata);\n              if (conflicts.length) {\n                doc.doc._conflicts = conflicts;\n              }\n            }\n            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n          }\n          if (item.deleted) {\n            if (opts.deleted === 'ok') {\n              doc.value.deleted = true;\n              doc.doc = null;\n            } else {\n              continue;\n            }\n          }\n          results.push(doc);\n        }\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = thisBtoa(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev = pos + '-' + revHash;\n          if (revs.indexOf(rev) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var _opts = $inject_Object_assign({\n    websql: openDB\n  }, opts);\n\n  WebSqlPouch$1.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nvar WebSqlPouch = function (PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n};\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise$1(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise$1.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  }).catch(function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body &&\n      options.processData &&\n      typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      result.status = response.statusCode;\n      callback(result);\n    }\n  }).catch(function (error) {\n    if (!error) {\n      // this happens when the listener is canceled\n      error = new Error('canceled');\n    }\n    callback(error);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function () {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function () {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = {abort: abortReq};\n\n  var cleanUp = function () {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if (xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch (e) {}\n      }\n      err.status = xhr.status;\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax$1(options, callback) {\n  if (!false && (hasXhr || options.xhr)) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\nvar res$2 = function () {};\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore$1(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = $inject_Object_assign(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      res$2(obj, resp);\n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax$1(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = (isSafari ||\n    ((isIE || isEdge) && opts.method === 'GET'));\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore$1(opts, callback);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new PouchPromise$1(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var atts = row.doc && row.doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$2(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise$1.resolve();\n  }\n\n  return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise$1(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = thisBtoa(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax;\n\n  function ajax$$1(userOpts, options, callback) {\n    var reqAjax = userOpts.ajax || {};\n    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n    var defaultHeaders = clone(ajaxOpts.headers || {});\n    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,\n      options.headers || {});\n    /* istanbul ignore if */\n    if (api.constructor.listeners('debug').length) {\n      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n    }\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      ajax$$1(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise$1.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise$1.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise$1.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ajax$$1({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid$$1 = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    });\n  });\n\n  api.request = adapterFun$$1('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax$$1({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax$$1(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      ajax$$1(opts, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, cb);\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'latest']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax$$1({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    }).catch(callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob$$1) {\n          if (opts.binary) {\n            return blob$$1;\n          }\n          return new PouchPromise$1(function (resolve) {\n            blobToBase64(blob$$1, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetch(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise$1.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise$1.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    }).catch(callback);\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax$$1(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax$$1(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n\n    ajax$$1({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$1('putAttachment', function (docId, attachmentId, rev, blob$$1,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob$$1;\n      blob$$1 = rev;\n      rev = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    if (typeof blob$$1 === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob$$1);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob$$1 = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob$$1,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax$$1({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));\n    }).then(function () {\n      // Update/create the documents\n      ajax$$1(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$2(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax$$1(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    }).catch(callback);\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n    opts.timeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // We give a 5 second buffer for CouchDB changes to respond with\n    // an ok timeout (if a timeout it set)\n    var params = opts.timeout ? {timeout: opts.timeout - (5 * 1000)} : {};\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    } else if (opts.continuous) {\n      // Default heartbeat to 10 seconds\n      params.heartbeat = 10000;\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: opts.timeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax$$1(opts, xhrOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax$$1(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax$$1(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nvar HttpPouch$1 = function (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n};\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue$2() {\n  this.promise = new PouchPromise$1(function (fulfill) {fulfill(); });\n}\nTaskQueue$2.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$2.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$2();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return PouchPromise$1.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return PouchPromise$1.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return PouchPromise$1.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$2();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$2();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        return fetchFromView(viewOpts);\n      });\n      return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return PouchPromise$1.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = PouchPromise$1.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  if (builtInReduce[reduceFun]) {\n    return builtInReduce[reduceFun];\n  } else {\n    return evalFunctionWithEval(reduceFun.toString());\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev) {\n  return /^1-/.test(rev);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise$1.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise$1.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return PouchPromise$1.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  return updateCheckpoint(this.target, this.id, checkpoint,\n    session, this.returnValue);\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  var self = this;\n  if (this.readOnlySource) {\n    return PouchPromise$1.resolve(true);\n  }\n  return updateCheckpoint(this.src, this.id, checkpoint,\n    session, this.returnValue)\n    .catch(function (err) {\n      if (isForbiddenError(err)) {\n        self.readOnlySource = true;\n        return true;\n      }\n      throw err;\n    });\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.readOnlySource) {\n      return PouchPromise$1.resolve(targetDoc.last_seq);\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.readOnlySource = true;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new PouchPromise$1(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise$1.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n      checkpointer = new Checkpointer(src, target, repId, returnValue);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, events.EventEmitter);\nfunction Replication() {\n  events.EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, events.EventEmitter);\nfunction sync$1(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise$1.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync$1;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      return {\n        from: function (other, opts, callback) {\n          return self.constructor.replicate(other, self, opts, callback);\n        },\n        to: function (other, opts, callback) {\n          return self.constructor.replicate(self, other, opts, callback);\n        }\n      };\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB$5.plugin(IDBPouch)\n  .plugin(WebSqlPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\nmodule.exports = PouchDB$5;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (factory) {\n    if (true) {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(11),\n  /* template */\n  __webpack_require__(60),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(12),\n  /* template */\n  __webpack_require__(61),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(68)\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(13),\n  /* template */\n  __webpack_require__(62),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(69)\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(14),\n  /* template */\n  __webpack_require__(63),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(65)\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(15),\n  /* template */\n  __webpack_require__(54),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(67)\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(16),\n  /* template */\n  __webpack_require__(59),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(66)\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(17),\n  /* template */\n  __webpack_require__(57),\n  /* scopeId */\n  \"data-v-54cb82b4\",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(18),\n  /* template */\n  __webpack_require__(56),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(19),\n  /* template */\n  __webpack_require__(58),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(0)(\n  /* script */\n  __webpack_require__(20),\n  /* template */\n  __webpack_require__(55),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"pixelParallel\"\n    }\n  }, [_c('panel', {\n    attrs: {\n      \"config\": _vm.config,\n      \"on-image-change\": _vm.handleImageChange,\n      \"on-disable-click\": _vm.handleDisableClick\n    }\n  }), _vm._v(\" \"), _c('overlay', {\n    attrs: {\n      \"config\": _vm.config,\n      \"image\": _vm.image\n    }\n  })], 1)\n},staticRenderFns: []}\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    class: _vm.imageOuterClasses,\n    style: ({\n      'height': (_vm.imageOuterHeight + \"px\")\n    })\n  }, [_c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: ({\n        x: true,\n        y: true,\n        onDragEnd: _vm.handleDragEnd\n      }),\n      expression: \"{x: true, y: true, onDragEnd: handleDragEnd}\"\n    }],\n    staticClass: \"pixelParallel-image-inner\",\n    style: (_vm.imageInnerStyles)\n  }, [_c('img', {\n    staticClass: \"pixelParallel-image\",\n    style: (_vm.imageStyles),\n    attrs: {\n      \"alt\": \"PixelParallel Image\",\n      \"src\": _vm.image.base64string\n    }\n  })])])\n},staticRenderFns: []}\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', {\n    staticClass: \"btn btn-block btn-file\"\n  }, [_vm._v(\"\\n  \" + _vm._s(_vm.title) + \"\\n\\n  \"), _c('input', {\n    attrs: {\n      \"type\": \"file\"\n    },\n    on: {\n      \"change\": _vm.changeHandler\n    }\n  })])\n},staticRenderFns: []}\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', {\n    staticClass: \"paste-box mousetrap\",\n    attrs: {\n      \"title\": _vm.title,\n      \"contenteditable\": \"true\"\n    },\n    on: {\n      \"paste\": _vm.pasteHandler\n    }\n  })\n},staticRenderFns: []}\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: ({\n        x: true,\n        y: true,\n        onDragEnd: _vm.handleDragEnd,\n        onDragMove: _vm.handleDragMove,\n        onDragStart: _vm.handleDragStart\n      }),\n      expression: \"{x: true, y: true, onDragEnd: handleDragEnd, onDragMove: handleDragMove, onDragStart: handleDragStart}\"\n    }],\n    class: ['pixelParallel-panel', {\n      'pixelParallel-panel-minimized': _vm.config.minimized,\n      'pixelParallel-panel-dragging': this.dragging\n    }],\n    style: (_vm.panelInlineStyles)\n  }, [_c('div', {\n    staticClass: \"pixelParallel-panel-inner\"\n  }, [_c('div', {\n    staticClass: \"pixelParallel-panel-handle\"\n  }), _vm._v(\" \"), _c('iframe', {\n    staticClass: \"pixelParallel-panel-isolator\",\n    attrs: {\n      \"frameborder\": \"0\"\n    }\n  }), _vm._v(\" \"), _c('div', {\n    class: ['pixelParallel-panel-content', {\n      'pixelParallel-panel-content-minimized': _vm.config.minimized\n    }]\n  }, [_c('droparea', {\n    attrs: {\n      \"title\": \"Drop Here\",\n      \"on-upload\": _vm.handleImageChange\n    }\n  }), _vm._v(\" \"), _c('header', {\n    staticClass: \"header\"\n  }, [_c('div', {\n    staticClass: \"panel-control\"\n  }, [_c('ul', [_c('li', [_c('a', {\n    class: {\n      'active': !_vm.config.visible\n    },\n    attrs: {\n      \"href\": \"#\",\n      \"title\": \"Hide All Elements\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.visible = !_vm.config.visible\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-eye-slash-small\"\n  })])]), _vm._v(\" \"), _c('li', [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.minimized = !_vm.config.minimized\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-minimize\"\n  }), _vm._v(\" \"), _c('i', {\n    staticClass: \"ico ico-maximize\"\n  })])]), _vm._v(\" \"), _c('li', [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.handleCloseClick($event)\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-close\"\n  })])])])]), _vm._v(\" \"), _c('nav', {\n    staticClass: \"nav\"\n  }, [_c('ul', [_c('li', {\n    class: {\n      'current': _vm.config.currentPane === 'image'\n    }\n  }, [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.setCurrentPane('image')\n      }\n    }\n  }, [_vm._v(\"Image\")])]), _vm._v(\" \"), _c('li', {\n    class: {\n      'current': _vm.config.currentPane === 'grid'\n    }\n  }, [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.setCurrentPane('grid')\n      }\n    }\n  }, [_vm._v(\"Grid \"), _c('span', {\n    staticClass: \"ad\"\n  }, [_vm._v(\"and Rulers\")])])])])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"main\"\n  }, [_c('div', {\n    staticClass: \"panes\"\n  }, [(_vm.config.currentPane === 'image') ? _c('div', {\n    staticClass: \"pane\"\n  }, [_c('div', {\n    staticClass: \"row row-head row-head-large-gutter\"\n  }, [_c('div', {\n    staticClass: \"col col-2-of-5\"\n  }, [_c('upload-button', {\n    attrs: {\n      \"title\": \"Upload Image\",\n      \"on-upload\": _vm.handleImageChange\n    }\n  })], 1), _vm._v(\" \"), _vm._m(0), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-2-of-5\"\n  }, [_c('paste-box', {\n    attrs: {\n      \"title\": \"Paste Here\",\n      \"on-paste\": _vm.handleImageChange\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"row row-head\"\n  }, [_c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Top\"\n    },\n    model: {\n      value: (_vm.config.image.top),\n      callback: function($$v) {\n        _vm.config.image.top = $$v\n      },\n      expression: \"config.image.top\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Left\"\n    },\n    model: {\n      value: (_vm.config.image.left),\n      callback: function($$v) {\n        _vm.config.image.left = $$v\n      },\n      expression: \"config.image.left\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Opacity\",\n      \"arrows\": true,\n      \"step\": .1,\n      \"min\": 0,\n      \"max\": 1\n    },\n    model: {\n      value: (_vm.config.image.opacity),\n      callback: function($$v) {\n        _vm.config.image.opacity = $$v\n      },\n      expression: \"config.image.opacity\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Scale\",\n      \"min\": 0,\n      \"max\": 3,\n      \"step\": .05\n    },\n    model: {\n      value: (_vm.config.image.scale),\n      callback: function($$v) {\n        _vm.config.image.scale = $$v\n      },\n      expression: \"config.image.scale\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"row\"\n  }, [_c('div', {\n    staticClass: \"col\"\n  }, [_c('div', {\n    staticClass: \"icon-link-group\"\n  }, [_c('a', {\n    staticClass: \"icon-link\",\n    class: {\n      'active': _vm.config.image.difference\n    },\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.image.difference = !_vm.config.image.difference\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-color\"\n  }), _vm._v(\" \"), _c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(\"Color Diff\")])]), _vm._v(\" \"), _c('a', {\n    staticClass: \"icon-link\",\n    class: {\n      'active': _vm.config.image.lock\n    },\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.image.lock = !_vm.config.image.lock\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-lock\"\n  }), _vm._v(\" \"), _c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(\"Lock\")])]), _vm._v(\" \"), _c('a', {\n    staticClass: \"icon-link\",\n    class: {\n      'active': !_vm.config.image.enabled\n    },\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.image.enabled = !_vm.config.image.enabled\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-eye-slash\"\n  }), _vm._v(\" \"), _c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(\"Hide Image\")])])])])])]) : _vm._e(), _vm._v(\" \"), (_vm.config.currentPane === 'grid') ? _c('div', {\n    staticClass: \"pane\"\n  }, [_c('div', {\n    staticClass: \"row row-head\"\n  }, [_c('div', {\n    staticClass: \"col col-1-of-3\"\n  }, [_c('toggle', {\n    attrs: {\n      \"title\": \"Layout Grid\"\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.enabled),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.enabled = $$v\n      },\n      expression: \"config.horizontalGrid.enabled\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-3\"\n  }, [_c('toggle', {\n    attrs: {\n      \"title\": \"Baseline Grid\"\n    },\n    model: {\n      value: (_vm.config.verticalGrid.enabled),\n      callback: function($$v) {\n        _vm.config.verticalGrid.enabled = $$v\n      },\n      expression: \"config.verticalGrid.enabled\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-3\"\n  }, [_c('toggle', {\n    attrs: {\n      \"title\": \"Rulers\",\n      \"action\": {\n        text: '(reset)',\n        handler: this.handleRulersReset\n      }\n    },\n    model: {\n      value: (_vm.config.rulers.enabled),\n      callback: function($$v) {\n        _vm.config.rulers.enabled = $$v\n      },\n      expression: \"config.rulers.enabled\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"row row-head\"\n  }, [_c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Width\",\n      \"min\": 0\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.width),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.width = $$v\n      },\n      expression: \"config.horizontalGrid.width\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Columns\",\n      \"min\": 0\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.columns),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.columns = $$v\n      },\n      expression: \"config.horizontalGrid.columns\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Gutter\",\n      \"min\": 0\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.gutter),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.gutter = $$v\n      },\n      expression: \"config.horizontalGrid.gutter\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Opacity\",\n      \"arrows\": true,\n      \"step\": .1,\n      \"min\": 0,\n      \"max\": 1\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.opacity),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.opacity = $$v\n      },\n      expression: \"config.horizontalGrid.opacity\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"row\"\n  }, [_c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Baseline\",\n      \"min\": 1\n    },\n    model: {\n      value: (_vm.config.verticalGrid.gutter),\n      callback: function($$v) {\n        _vm.config.verticalGrid.gutter = $$v\n      },\n      expression: \"config.verticalGrid.gutter\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Opacity\",\n      \"arrows\": true,\n      \"step\": .1,\n      \"min\": 0,\n      \"max\": 1\n    },\n    model: {\n      value: (_vm.config.verticalGrid.opacity),\n      callback: function($$v) {\n        _vm.config.verticalGrid.opacity = $$v\n      },\n      expression: \"config.verticalGrid.opacity\"\n    }\n  })], 1)])]) : _vm._e()])])], 1)], 1)])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"col col-1-of-5\"\n  }, [_c('span', {\n    staticClass: \"elements-divider\"\n  }, [_vm._v(\"or\")])])\n}]}\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('label', {\n    class: ['toggle', {\n      'toggle-checked': _vm.checked\n    }]\n  }, [_c('span', {\n    staticClass: \"toggle-title\"\n  }, [_vm._v(_vm._s(_vm.title) + \" \"), (_vm.action) ? _c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.action.handler($event)\n      }\n    }\n  }, [_vm._v(_vm._s(_vm.action.text))]) : _vm._e()]), _vm._v(\" \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.checked),\n      expression: \"checked\"\n    }],\n    staticClass: \"toggle-checkbox\",\n    attrs: {\n      \"type\": \"checkbox\"\n    },\n    domProps: {\n      \"checked\": Array.isArray(_vm.checked) ? _vm._i(_vm.checked, null) > -1 : (_vm.checked)\n    },\n    on: {\n      \"__c\": function($event) {\n        var $$a = _vm.checked,\n          $$el = $event.target,\n          $$c = $$el.checked ? (true) : (false);\n        if (Array.isArray($$a)) {\n          var $$v = null,\n            $$i = _vm._i($$a, $$v);\n          if ($$c) {\n            $$i < 0 && (_vm.checked = $$a.concat($$v))\n          } else {\n            $$i > -1 && (_vm.checked = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))\n          }\n        } else {\n          _vm.checked = $$c\n        }\n      }\n    }\n  }), _vm._v(\" \"), _vm._m(0)])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', {\n    staticClass: \"toggle-main\"\n  }, [_c('span', {\n    staticClass: \"toggle-handle\"\n  })])\n}]}\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    class: ['pixelParallel-rulers', {\n      'pixelParallel-rulers-enabled': _vm.config.rulers.enabled\n    }]\n  }, [_c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: ({\n        y: true,\n        onDragEnd: _vm.handleXDragEnd\n      }),\n      expression: \"{y: true, onDragEnd: handleXDragEnd}\"\n    }],\n    staticClass: \"pixelParallel-ruler-x\",\n    style: ({\n      'margin-top': ((_vm.config.rulers.x) + \"px\")\n    })\n  }), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: ({\n        x: true,\n        onDragEnd: _vm.handleYDragEnd\n      }),\n      expression: \"{x: true, onDragEnd: handleYDragEnd}\"\n    }],\n    staticClass: \"pixelParallel-ruler-y\",\n    style: ({\n      'margin-left': ((_vm.config.rulers.y) + \"px\")\n    })\n  })])\n},staticRenderFns: []}\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    class: ['droparea', {\n      'enabled': _vm.enabled\n    }]\n  }, [_c('span', {\n    staticClass: \"droparea-title\"\n  }, [_vm._v(_vm._s(_vm.title))]), _vm._v(\" \"), _c('input', {\n    attrs: {\n      \"type\": \"file\"\n    },\n    on: {\n      \"change\": _vm.changeHandler\n    }\n  })])\n},staticRenderFns: []}\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('label', {\n    staticClass: \"number\"\n  }, [_c('span', {\n    staticClass: \"number-title\"\n  }, [_vm._v(_vm._s(_vm.title))]), _vm._v(\" \"), _c('span', {\n    staticClass: \"number-field\"\n  }, [(_vm.arrows) ? _c('span', {\n    staticClass: \"number-arrows\"\n  }, [_c('span', {\n    staticClass: \"number-arrow number-arrow-up\",\n    on: {\n      \"mousedown\": function($event) {\n        $event.preventDefault();\n        _vm.startIncrement($event, _vm.step)\n      }\n    }\n  }, [_vm._v(\"+\")]), _vm._v(\" \"), _c('span', {\n    staticClass: \"number-arrow number-arrow-down\",\n    on: {\n      \"mousedown\": function($event) {\n        $event.preventDefault();\n        _vm.startIncrement($event, -_vm.step)\n      }\n    }\n  }, [_vm._v(\"-\")])]) : _vm._e(), _vm._v(\" \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.inputVal),\n      expression: \"inputVal\"\n    }],\n    staticClass: \"number-input\",\n    attrs: {\n      \"type\": \"number\",\n      \"step\": _vm.step,\n      \"min\": _vm.min,\n      \"max\": _vm.max\n    },\n    domProps: {\n      \"value\": (_vm.inputVal)\n    },\n    on: {\n      \"input\": function($event) {\n        if ($event.target.composing) { return; }\n        _vm.inputVal = $event.target.value\n      },\n      \"blur\": function($event) {\n        _vm.$forceUpdate()\n      }\n    }\n  })])])\n},staticRenderFns: []}\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    class: ['pixelParallel-overlay', {\n      'pixelParallel-overlay-enabled': _vm.config.visible\n    }]\n  }, [_c('overlayGrids', {\n    attrs: {\n      \"config\": _vm.config\n    }\n  }), _vm._v(\" \"), _c('overlayImage', {\n    attrs: {\n      \"config\": _vm.config,\n      \"image\": _vm.image\n    }\n  }), _vm._v(\" \"), _c('overlayRulers', {\n    attrs: {\n      \"config\": _vm.config\n    }\n  })], 1)\n},staticRenderFns: []}\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"pixelParallel-grids\"\n  }, [_c('div', {\n    class: ['pixelParallel-grid-horizontal', {\n      'pixelParallel-grid-horizontal-enabled': _vm.config.horizontalGrid.enabled\n    }],\n    style: (_vm.horizontalGridStyles)\n  }, _vm._l(((parseInt(_vm.config.horizontalGrid.columns) || 1)), function(val) {\n    return _c('span')\n  })), _vm._v(\" \"), _c('div', {\n    class: ['pixelParallel-grid-vertical', {\n      'pixelParallel-grid-vertical-enabled': _vm.config.verticalGrid.enabled\n    }],\n    style: (_vm.verticalGridStyles)\n  })])\n},staticRenderFns: []}\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(26);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"0a9ac382\", content, true);\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(27);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"65692d52\", content, true);\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(28);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"50d13449\", content, true);\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(29);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"41341762\", content, true);\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(30);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"454c1251\", content, true);\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(31);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(2)(\"aa5febfc\", content, true);\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports) {\n\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// PixelParallel.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 21);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fd38e2883e8fc55d4c96","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 0\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 1\n// module chunks = 0","/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = require('./listToStyles')\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/lib/addStylesClient.js\n// module id = 2\n// module chunks = 0","function getFileTypeFromBase64string(input) {\r\n  return input.replace('data:', '').split(';base64')[0];\r\n}\r\n\r\nfunction getBase64FromFile(file) {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new window.FileReader();\r\n\r\n    reader.onload = () => {\r\n      resolve(reader.result);\r\n    };\r\n\r\n    reader.onerror = () => reject;\r\n\r\n    reader.readAsDataURL(file);\r\n  });\r\n}\r\n\r\nfunction getImageFromPasteEvent(event) {\r\n  return new Promise((resolve, reject) => {\r\n    if (!event.clipboardData.items) {\r\n      const waitInterval = setInterval(() => {\r\n        if (this.event.target.children.length > 0) {\r\n          clearInterval(waitInterval);\r\n\r\n          resolve({\r\n            base64string: this.event.target.children[0].src,\r\n            type: getFileTypeFromBase64string(this.event.target.children[0].src)\r\n          });\r\n\r\n          this.event.target.innerHTML = '';\r\n        }\r\n      }, 1);\r\n\r\n    } else {\r\n      Array.from(event.clipboardData.items).some((item) => {\r\n        if (item.kind === 'file' && (item.type === 'image/png' || item.type === 'image/jpeg')) {\r\n          const file = item.getAsFile();\r\n\r\n          const imageType = item.type;\r\n\r\n          getBase64FromFile(file).then((result) => {\r\n            resolve({\r\n              base64string: result,\r\n              type: imageType\r\n            });\r\n          });\r\n\r\n          return true;\r\n        }\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\nfunction getImageFromInputEvent(event) {\r\n  return new Promise((resolve, reject) => {\r\n    if (event.target.files && event.target.files[0]) {\r\n      getBase64FromFile(event.target.files[0]).then((result) => {\r\n        resolve({\r\n          base64string: result,\r\n          type: event.target.files[0].type\r\n        });\r\n      });\r\n    } else {\r\n      reject();\r\n    }\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * Simple is object check.\r\n * @param item\r\n * @returns {boolean}\r\n */\r\nfunction isObject(item) {\r\n  return (item && typeof item === 'object' && !Array.isArray(item));\r\n}\r\n\r\n/**\r\n * Deep merge two objects.\r\n * @param target\r\n * @param source\r\n */\r\nfunction mergeDeep(target, source) {\r\n  if (isObject(target) && isObject(source)) {\r\n    for (const key in source) {\r\n      if (isObject(source[key])) {\r\n        if (!target[key]) Object.assign(target, { [key]: {} });\r\n        mergeDeep(target[key], source[key]);\r\n      } else {\r\n        Object.assign(target, { [key]: source[key] });\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n}\r\n\r\nexport default {\r\n  getImageFromPasteEvent,\r\n  getImageFromInputEvent,\r\n  mergeDeep\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/utils.js","export default {\r\n  inserted: function (el, bindings) {\r\n    draggableElement(el, bindings.value);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Enables draggable functionality to an element\r\n * @param  {Element} element\r\n * @param  {Object} settings Callbacks\r\n */\r\nfunction draggableElement(element, settings) {\r\n  let elementDraggable = false;\r\n  const startPosition = {\r\n    left: 0,\r\n    top: 0\r\n  };\r\n  const elementMargin = {\r\n    left: 0,\r\n    top: 0\r\n  };\r\n\r\n  const elementInitialMargin = {\r\n    left: 0,\r\n    top: 0\r\n  };\r\n\r\n  const mouseUpHandler = function(event) {\r\n    elementDraggable = false;\r\n    document.removeEventListener('mouseup', mouseUpHandler);\r\n    document.removeEventListener('mousemove', mouseMoveHandler);\r\n\r\n    if('onDragEnd' in settings) {\r\n      settings.onDragEnd(elementMargin, event);\r\n    };\r\n  };\r\n\r\n  const mouseMoveHandler = function(event) {\r\n    if (elementDraggable) {\r\n\r\n      if('onDragMove' in settings) {\r\n        settings.onDragMove(event);\r\n\r\n        return;\r\n      };\r\n\r\n      if (settings.y) {\r\n        elementMargin.top = (event.pageY - startPosition.top) + elementInitialMargin.top;\r\n        element.style.marginTop = elementMargin.top + 'px';\r\n      }\r\n\r\n      if (settings.x) {\r\n        elementMargin.left = (event.pageX - startPosition.left) + elementInitialMargin.left;\r\n        element.style.marginLeft = elementMargin.left + 'px';\r\n      }\r\n\r\n    }\r\n  };\r\n\r\n  const mouseDownHandler = function(event) {\r\n    event.preventDefault();\r\n    elementDraggable = true;\r\n\r\n      if('onDragStart' in settings) {\r\n        settings.onDragStart(event);\r\n      };\r\n\r\n\r\n    if (settings.y) {\r\n      startPosition.top = event.pageY;\r\n      elementMargin.top = parseInt(element.style.marginTop || 0);\r\n      elementInitialMargin.top = elementMargin.top;\r\n    }\r\n\r\n    if (settings.x) {\r\n      startPosition.left = event.pageX;\r\n      elementMargin.left = parseInt(element.style.marginLeft || 0);\r\n      elementInitialMargin.left = elementMargin.left;\r\n    }\r\n\r\n    document.addEventListener('mouseup', mouseUpHandler);\r\n    document.addEventListener('mousemove', mouseMoveHandler);\r\n  }\r\n\r\n  element.addEventListener('mousedown', mouseDownHandler);\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/directives/draggable.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 5\n// module chunks = 0","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/immediate/lib/browser.js\n// module id = 6\n// module chunks = 0","\n/* styles */\nrequire(\"!!vue-style-loader!css-loader?minimize!../node_modules/vue-loader/lib/style-rewriter?id=data-v-02abf5a2!../node_modules/vue-loader/lib/selector?type=styles&index=0!./PixelParallel.vue\")\n\nvar Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./PixelParallel.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler?id=data-v-02abf5a2!../node_modules/vue-loader/lib/selector?type=template&index=0!./PixelParallel.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PixelParallel.vue\n// module id = 7\n// module chunks = 0","/*!\n * Vue.js v2.3.3\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    } )); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdateHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdateHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = {\n  key: 1,\n  ref: 1,\n  slot: 1\n};\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key] || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production') {\n      if (getter === undefined) {\n        warn(\n          (\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var result = Object.create(null);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      // return nothing if this is indeed an async component\n      // wait for the callback to trigger parent update.\n      return\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return this\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.3.3';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (isUndef(value)) {\n    return ''\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  var res = '';\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(value[i])) {\n        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        if (ref.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n              typeof console !== 'undefined' &&\n              !bailed\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    process.env.NODE_ENV !== 'production' && warn &&\n    modifiers && modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((isDef(modifiers) && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n    config.productionTip !== false &&\n    inBrowser && typeof console !== 'undefined'\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (process.env.NODE_ENV !== 'production' &&\n      name === 'click' &&\n      handler && handler.modifiers && handler.modifiers.right\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, warn$3)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, warn$3)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}}\"\n}\n\nfunction genForScopedSlot (key, el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el)) +\n    '})'\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue/dist/vue.common.js\n// module id = 8\n// module chunks = 0","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/argsarray/index.js\n// module id = 9\n// module chunks = 0","<template>\r\n  <div id=\"pixelParallel\">\r\n    <panel :config=\"config\" :on-image-change=\"handleImageChange\" :on-disable-click=\"handleDisableClick\" />\r\n\r\n    <overlay :config=\"config\" :image=\"image\" />\r\n  </div>\r\n\r\n</template>\r\n\r\n<script>\r\nimport Mousetrap from 'mousetrap';\r\nimport './../node_modules/mousetrap/plugins/pause/mousetrap-pause.js';\r\nimport DB from './utils/db.js';\r\nimport utils from './utils/utils.js';\r\nimport Panel from './components/Panel.vue';\r\nimport Overlay from './components/Overlay.vue';\r\n\r\nconst db = new DB();\r\n\r\nconst mousetrap = {\r\n  main: new Mousetrap(window),\r\n  panel: null\r\n};\r\n\r\nexport default {\r\n  name: 'pixelParallel',\r\n  data () {\r\n    return {\r\n      enabled: true,\r\n      config: {\r\n        currentPane: 'image',\r\n        visible: true,\r\n        minimized: true,\r\n        horizontalGrid: {\r\n          enabled: false,\r\n          width: 960,\r\n          columns: 12,\r\n          gutter: 30,\r\n          opacity: .2\r\n        },\r\n        verticalGrid: {\r\n          enabled: false,\r\n          gutter: 30,\r\n          opacity: .1\r\n\r\n        },\r\n        rulers: {\r\n          enabled: false,\r\n          x: 10,\r\n          y: 10\r\n        },\r\n        image: {\r\n          top: 0,\r\n          left: 0,\r\n          opacity: .5,\r\n          scale: 1,\r\n          difference: false,\r\n          lock: false,\r\n          enabled: true\r\n        },\r\n        position: {\r\n          x: {\r\n            name: 'right',\r\n            value: .5\r\n          },\r\n          y: {\r\n            name: 'bottom',\r\n            value: 1\r\n          }\r\n        }\r\n      },\r\n      image: {\r\n        base64string: null,\r\n        type: null\r\n      }\r\n    }\r\n  },\r\n\r\n  beforeCreate() {\r\n    db.getProps().then((config) => {\r\n      this.config = utils.mergeDeep(this.config, config);\r\n    }).catch(() => {\r\n      // No entry in the db\r\n      this.config.minimized = false;\r\n    });\r\n\r\n    db.getImage().then((imageObject) => {\r\n      this.image = imageObject;\r\n    }).catch(() => {});\r\n\r\n    if ('chrome' in window && 'extension' in chrome) {\r\n      chrome.extension.onMessage.addListener((msg, sender, sendResponse) => {\r\n\r\n        switch (msg) {\r\n          case 'enable':\r\n            this.enable();\r\n            break;\r\n\r\n          case 'disable':\r\n            this.disable();\r\n            break;\r\n\r\n          case 'reloadBindings':\r\n            this.reloadBindings();\r\n            break;\r\n        }\r\n      });\r\n    }\r\n  },\r\n  mounted() {\r\n    if ('chrome' in window && 'extension' in chrome) {\r\n      this.disable();\r\n      chrome.runtime.sendMessage('isEnabled', (response) => {\r\n        if (response === true) {\r\n          this.enable();\r\n        }\r\n      });\r\n    } else {\r\n      this.enable();\r\n    }\r\n\r\n    this.reloadBindings();\r\n  },\r\n\r\n  watch: {\r\n    config: {\r\n      handler(newVal) {\r\n        db.setProps(newVal);\r\n      },\r\n      deep: true\r\n    },\r\n    image: {\r\n      handler(newVal) {\r\n        db.setImage(newVal);\r\n      }\r\n    }\r\n  },\r\n\r\n  methods: {\r\n    disable() {\r\n      if (!this.enabled) {\r\n        return;\r\n      }\r\n\r\n      this.enabled = false;\r\n\r\n      if (mousetrap.main) mousetrap.main.pause();\r\n      if (mousetrap.panel) mousetrap.panel.pause();\r\n\r\n      this.$children[0].detach();\r\n\r\n      document.body.removeChild(this.$el);\r\n    },\r\n    enable() {\r\n      if (this.enabled) {\r\n        return;\r\n      }\r\n\r\n      this.enabled = true;\r\n\r\n      if (mousetrap.main) mousetrap.main.unpause();\r\n      if (mousetrap.panel) mousetrap.panel.unpause();\r\n\r\n      document.body.appendChild(this.$el);\r\n\r\n      this.$children[0].attach();\r\n\r\n      this.reloadBindings();\r\n    },\r\n    handleImageChange(imageObject) {\r\n      this.image = imageObject;\r\n    },\r\n    handleDisableClick() {\r\n      if ('chrome' in window && 'runtime' in chrome && 'sendMessage' in chrome.runtime) {\r\n        chrome.runtime.sendMessage('panelDisabled');\r\n      }\r\n\r\n      this.disable();\r\n    },\r\n    bindKeyboard(bindings, element) {\r\n      const instance = Mousetrap(element || window);\r\n\r\n      if (mousetrap.main) {\r\n        mousetrap.main.reset();\r\n      }\r\n\r\n      if (mousetrap.panel) {\r\n        mousetrap.panel.reset();\r\n      }\r\n\r\n      setTimeout(() => {\r\n        Object.keys(bindings).forEach((key) => {\r\n          const keyString = bindings[key].base ? `ctrl+alt+${bindings[key].key}` : bindings[key].key;\r\n          const keyStringWithShift = bindings[key].base ? `ctrl+alt+shift+${bindings[key].key}` : `shift+${bindings[key].key}`;\r\n\r\n          instance\r\n            .bind(keyString, (event) => {\r\n              event.preventDefault();\r\n\r\n              switch (key) {\r\n                case 'minimize':\r\n                  this.config.minimized = !this.config.minimized;\r\n                  break;\r\n\r\n                case 'toggle':\r\n                  this.config.visible = !this.config.visible;\r\n                  break;\r\n\r\n                case 'lock':\r\n                  this.config.image.lock = !this.config.image.lock;\r\n                  break;\r\n\r\n                case 'resetPosition':\r\n                  this.config.image.top = 0;\r\n                  this.config.image.left = 0;\r\n                  break;\r\n\r\n                case 'left':\r\n                  this.config.image.left -= 1;\r\n                  break;\r\n\r\n                case 'right':\r\n                  this.config.image.left += 1;\r\n                  break;\r\n\r\n                case 'up':\r\n                  this.config.image.top -= 1;\r\n                  break;\r\n\r\n                case 'down':\r\n                  this.config.image.top += 1;\r\n                  break;\r\n              }\r\n            });\r\n\r\n          if (key === 'left' || key === 'right' || key === 'up' || key === 'down') {\r\n            instance\r\n              .bind(keyStringWithShift, (event) => {\r\n                event.preventDefault();\r\n\r\n                switch (key) {\r\n                  case 'left':\r\n                    this.config.image.left -= 10;\r\n                    break;\r\n\r\n                  case 'right':\r\n                    this.config.image.left += 10;\r\n                    break;\r\n\r\n                  case 'up':\r\n                    this.config.image.top -= 10;\r\n                    break;\r\n\r\n                  case 'down':\r\n                    this.config.image.top += 10;\r\n                    break;\r\n                }\r\n              });\r\n          }\r\n        });\r\n\r\n        if (element) {\r\n          mousetrap.panel = instance;\r\n        } else {\r\n          mousetrap.main = instance;\r\n        }\r\n        \r\n      });\r\n    },\r\n    reloadBindings() {\r\n      const defaultBindings = {\r\n        minimize: {\r\n          base: true,\r\n          key: 'm'\r\n        },\r\n        toggle: {\r\n          base: true,\r\n          key: 't'\r\n        },\r\n        lock: {\r\n          base: true,\r\n          key: 'l'\r\n        },\r\n        resetPosition: {\r\n          base: true,\r\n          key: '0'\r\n        },\r\n        left: {\r\n          base: true,\r\n          key: 'left'\r\n        },\r\n        right: {\r\n          base: true,\r\n          key: 'right'\r\n        },\r\n        up: {\r\n          base: true,\r\n          key: 'up'\r\n        },\r\n        down: {\r\n          base: true,\r\n          key: 'down'\r\n        }\r\n      };\r\n\r\n      if (mousetrap.main) {\r\n        mousetrap.main.reset();\r\n      }\r\n\r\n      if (mousetrap.panel) {\r\n        mousetrap.panel.reset();\r\n      }\r\n\r\n      if ('chrome' in window && 'storage' in chrome && 'sync' in chrome.storage) {\r\n        chrome.storage.sync.get(defaultBindings, (bindings) => {\r\n          this.bindKeyboard(bindings);\r\n\r\n          if (this.$children[0].isolatorElement.contentWindow) {\r\n            this.bindKeyboard(bindings, this.$children[0].isolatorElement.contentWindow);\r\n          }\r\n        });\r\n      } else {\r\n        this.bindKeyboard(defaultBindings);\r\n\r\n        if (this.$children[0].isolatorElement.contentWindow) {\r\n          this.bindKeyboard(defaultBindings, this.$children[0].isolatorElement.contentWindow);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  components: {\r\n    Panel,\r\n    Overlay\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// PixelParallel.vue?c863427c","<template>\r\n  <div :class=\"['droparea', {'enabled': enabled}]\">\r\n    <span class=\"droparea-title\">{{title}}</span>\r\n    <input type=\"file\" @change=\"changeHandler\">\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport utils from '../utils/utils.js';\r\n\r\nexport default {\r\n  name: 'droparea',\r\n\r\n  props: ['title', 'onUpload'],\r\n\r\n  data() {\r\n    return {\r\n      enabled: false,\r\n      parentDoc: document,\r\n      isolatorDoc: null\r\n    }\r\n  },\r\n\r\n  mounted() {\r\n    this.parentDoc.addEventListener('dragenter', ( event ) => {\r\n      this.attemptEnable(event);\r\n    }, false);\r\n\r\n    this.parentDoc.addEventListener('dragleave', ( event ) => {\r\n      this.enabled = false;\r\n    }, false);\r\n  },\r\n\r\n  methods: {\r\n    changeHandler(event) {\r\n      utils.getImageFromInputEvent(event).then((result) => {\r\n        this.onUpload({\r\n          base64string: result.base64string,\r\n          type: result.type\r\n        });\r\n      });\r\n    },\r\n    setIsolatorDoc(doc) {\r\n      this.isolatorDoc = doc;\r\n      this.bindIsolatorDoc()\r\n    },\r\n    attemptEnable(event) {\r\n      if ('dataTransfer' in event && 'items' in event.dataTransfer && event.dataTransfer.items.length === 1 && (event.dataTransfer.items[0].type === 'image/png' || event.dataTransfer.items[0].type === 'image/jpeg')) {\r\n        this.enabled = true;\r\n      }\r\n    },\r\n    bindIsolatorDoc() {\r\n\r\n      this.isolatorDoc.addEventListener('dragenter', ( event ) => {\r\n        this.attemptEnable(event);\r\n      }, false);\r\n\r\n      this.isolatorDoc.addEventListener('dragover', ( event ) => {\r\n          event.preventDefault();\r\n          this.attemptEnable(event);\r\n      }, false);\r\n\r\n\r\n      this.isolatorDoc.addEventListener('drop', ( event ) => {\r\n          this.enabled = false;\r\n        \r\n      }, false);\r\n\r\n    }\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// Droparea.vue?62344fe4","<template>\r\n  <label class=\"number\">\r\n    <span class=\"number-title\">{{title}}</span>\r\n\r\n    <span class=\"number-field\">\r\n      <span class=\"number-arrows\" v-if=\"arrows\">\r\n        <span class=\"number-arrow number-arrow-up\" @mousedown.prevent=\"startIncrement($event, step)\">+</span>\r\n\r\n        <span class=\"number-arrow number-arrow-down\" @mousedown.prevent=\"startIncrement($event, -step)\">-</span>\r\n      </span>\r\n\r\n      <input type=\"number\" class=\"number-input\" v-model=\"inputVal\" :step=\"step\" :min=\"min\" :max=\"max\">\r\n    </span>\r\n  </label>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'toggle',\r\n\r\n  props: ['title', 'value', 'arrows', 'step', 'min', 'max'],\r\n\r\n  computed: {\r\n    inputVal: {\r\n      get() {\r\n        return this.value;\r\n      },\r\n\r\n      set(val) {\r\n        this.$emit('input', val);   \r\n      }\r\n    }\r\n  },\r\n\r\n  methods: {\r\n    startIncrement(event, step) {\r\n      const doc = event.target.ownerDocument;\r\n      let newVal = this.inputVal;\r\n\r\n      const incrementStopHandler = (event) => {\r\n        if (event.type === 'mouseout' && (event.relatedTarget || event.toElement) && (event.relatedTarget || event.toElement).nodeName !== 'HTML') {\r\n          return;\r\n        }\r\n\r\n        if (this.incrementTimeout) {\r\n          clearTimeout(this.incrementTimeout);\r\n\r\n          this.incrementTimeout = null;\r\n        }\r\n\r\n        if (this.incrementInterval) {\r\n          clearInterval(this.incrementInterval);\r\n\r\n          this.incrementInterval = null;\r\n        }\r\n\r\n        doc.removeEventListener('mouseup', incrementStopHandler);\r\n        doc.removeEventListener('mouseout', incrementStopHandler);\r\n      };\r\n\r\n      const testNewVal = (newVal) => {\r\n        return !((typeof this.min !== 'undefined' && newVal < this.min) || (typeof this.max !== 'undefined' && newVal > this.max));\r\n      }\r\n\r\n      const roundVal = (val) => {\r\n        return Math.round(val * 100000) / 100000;\r\n      }\r\n\r\n      if (!testNewVal(this.inputVal + step)) {\r\n        return;\r\n      }\r\n\r\n      this.inputVal = roundVal(this.inputVal + step);\r\n\r\n      this.incrementTimeout = setTimeout(() => {\r\n        this.incrementInterval = setInterval(() => {\r\n\r\n          if (testNewVal(this.inputVal + step)) {\r\n            this.inputVal = roundVal(this.inputVal + step);\r\n          }\r\n\r\n        }, 80);\r\n\r\n      }, 150);\r\n\r\n      doc.addEventListener('mouseup', incrementStopHandler);\r\n      doc.addEventListener('mouseout', incrementStopHandler);\r\n    }\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// Number.vue?19a627e8","<template>\r\n  <div :class=\"['pixelParallel-overlay', {'pixelParallel-overlay-enabled': config.visible}]\" >\r\n    <overlayGrids :config=\"config\" />\r\n\r\n    <overlayImage :config=\"config\" :image=\"image\" />\r\n\r\n    <overlayRulers :config=\"config\" />\r\n  </div><!-- /.pixelParallel-overlay -->\r\n\r\n</template>\r\n\r\n<script>\r\nimport OverlayImage from './OverlayImage.vue';\r\nimport OverlayGrids from './OverlayGrids.vue';\r\nimport OverlayRulers from './OverlayRulers.vue';\r\n\r\nexport default {\r\n  name: 'overlay',\r\n\r\n  props: ['config', 'image'],\r\n\r\n  components: {\r\n    OverlayImage,\r\n    OverlayGrids,\r\n    OverlayRulers\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n  /*  Overlay  */\r\n  .pixelParallel-overlay { position: absolute; left: 0; top: 0; width: 100%; text-align: center; white-space: nowrap; display: none; }\r\n  .pixelParallel-overlay-enabled { display: block; }\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// Overlay.vue?13c1bf84","<template>\r\n  <div class=\"pixelParallel-grids\">\r\n    <div :class=\"['pixelParallel-grid-horizontal', {'pixelParallel-grid-horizontal-enabled': config.horizontalGrid.enabled}]\" :style=\"horizontalGridStyles\">\r\n      <span v-for=\"val in (parseInt(config.horizontalGrid.columns) || 1)\" />\r\n    </div>\r\n\r\n    <div :class=\"['pixelParallel-grid-vertical', {'pixelParallel-grid-vertical-enabled': config.verticalGrid.enabled}]\" :style=\"verticalGridStyles\"></div>\r\n  </div><!-- /.pixelParallel-grids -->\r\n</template>\r\n\r\n<script>\r\n\r\nexport default {\r\n  name: 'overlay-grids',\r\n\r\n  props: ['config'],\r\n\r\n  computed: {\r\n    horizontalGridStyles () {\r\n      const opacity = this.config.horizontalGrid.opacity;\r\n      const width = parseInt(this.config.horizontalGrid.width) || 0;\r\n      const gutter = parseInt(this.config.horizontalGrid.gutter) || 0;\r\n\r\n      return {\r\n        'opacity': opacity,\r\n        'border-spacing': `${gutter}px`,\r\n        'width': `${width ? `${width + gutter * 2}px` : `calc(100% + ${gutter * 2}px)`}`\r\n      };\r\n    },\r\n    verticalGridStyles() {\r\n      const opacity = this.config.verticalGrid.opacity;\r\n      const gutter = Math.max(3, parseInt(this.config.verticalGrid.gutter) || 0);\r\n      const gradientStop = 100 - (1 / gutter * 100);\r\n\r\n      return {\r\n        'opacity': opacity,\r\n        'background': `linear-gradient(to bottom, transparent, transparent ${gradientStop}%, blue ${gradientStop}%, blue)`,\r\n        'background-size': `100% ${gutter}px`\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n  /*  Overlay - Grids  */\r\n  .pixelParallel-grids { position: relative; z-index: 2147483646; pointer-events: none; }\r\n  .pixelParallel-grid-horizontal,\r\n  .pixelParallel-grid-vertical { position: fixed; z-index: 1; pointer-events: none; visibility: hidden; }\r\n\r\n  .pixelParallel-grid-horizontal { top: 50%; left: 50%; display: table; width: 100vw; height: 200vh; opacity: .5; table-layout: fixed; border-spacing: 30px; transform: translate(-50%, -50%); }\r\n  .pixelParallel-grid-horizontal span { display: table-cell; background: red; height: 200vh; }\r\n\r\n  .pixelParallel-grid-vertical { top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, transparent, transparent 90%, blue 90%, blue); background-size: 100% 10px; opacity: .5; }\r\n\r\n  /*  States  */\r\n  .pixelParallel-grid-horizontal-enabled { visibility: visible; }\r\n  .pixelParallel-grid-vertical-enabled { visibility: visible; }\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// OverlayGrids.vue?082dddc5","<template>\r\n  <div :class=\"imageOuterClasses\" :style=\"{'height': `${imageOuterHeight}px`}\">\r\n    <div class=\"pixelParallel-image-inner\" :style=\"imageInnerStyles\" v-draggable=\"{x: true, y: true, onDragEnd: handleDragEnd}\">\r\n      <img class=\"pixelParallel-image\" :style=\"imageStyles\" alt=\"PixelParallel Image\" :src=\"image.base64string\">\r\n    </div><!-- /.pixelParallel-image-inner -->\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n\r\nimport draggableDirective from '../directives/draggable.js';\r\n\r\nexport default {\r\n  name: 'overlayImage',\r\n\r\n  props: ['config', 'image'],\r\n\r\n  data () {\r\n    return {\r\n      imageOuterHeight: this.getDocumentHeight()\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    imageOuterClasses () {\r\n      return [\r\n        'pixelParallel-image-outer',\r\n        {\r\n          'pixelParallel-image-no-image': !this.image.base64string,\r\n          'pixelParallel-image-difference': this.config.image.difference,\r\n          'pixelParallel-image-locked': this.config.image.lock,\r\n          'pixelParallel-image-enabled': this.config.image.enabled\r\n        }\r\n      ];\r\n    },\r\n    imageInnerStyles () {\r\n      return {\r\n        'margin-left': `${this.config.image.left}px`,\r\n        'margin-top': `${this.config.image.top}px`\r\n      };\r\n    },\r\n    imageStyles () {\r\n      return {\r\n        'transform': `scale(${this.config.image.scale})`,\r\n        'opacity': this.config.image.opacity\r\n      };\r\n    }\r\n  },\r\n  methods: {\r\n    handleDragEnd (newPosition) {\r\n      this.config.image.top = newPosition.top;\r\n      this.config.image.left = newPosition.left;\r\n    },\r\n    getDocumentHeight() {\r\n      var body = document.body;\r\n      var html = document.documentElement;\r\n\r\n      return Math.max(document.documentElement.offsetHeight, body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\r\n    },\r\n    resizeOverlay () {\r\n      this.imageOuterHeight = 0;\r\n      this.imageOuterHeight = this.getDocumentHeight();\r\n    }\r\n  },\r\n  mounted () {\r\n    window.addEventListener('resize', this.resizeOverlay);\r\n\r\n    setInterval(this.resizeOverlay, 500);\r\n  },\r\n  directives: {\r\n    draggable: draggableDirective\r\n  }\r\n\r\n}\r\n</script>\r\n\r\n<style>\r\n  /*  Overlay - Image  */\r\n  .pixelParallel-image-outer { visibility: hidden; position: absolute; top: 0; left: 0; width: 100%; overflow: hidden; max-width: 100vw; min-height: 100vh; }\r\n  .pixelParallel-image-inner { position: absolute; z-index: 2147483646; left: 50%; top: 0; cursor: move; transform: translateX(-50%); transition: opacity .15s; }\r\n  .pixelParallel-image-inner img { width: auto; height: auto; max-width: none; max-height: none; vertical-align: top; margin: 0; padding: 0; position: relative; transform-origin: 50% 0%; top: -1px; border: 1px dashed #333; }\r\n  .pixelParallel-image-inner img[src=\"\"],\r\n  .pixelParallel-image-inner img:not([src]) { visibility: hidden; }\r\n\r\n  /*  States  */\r\n  .pixelParallel-image-enabled { visibility: visible; }\r\n  .pixelParallel-image-difference { mix-blend-mode: difference; }\r\n  .pixelParallel-image-difference img { opacity: 1 !important; }\r\n\r\n  .pixelParallel-image-no-image,\r\n  .pixelParallel-image-locked { pointer-events: none; }\r\n  .pixelParallel-image-locked .pixelParallel-image-inner img { top: 0; border: 0 none; }\r\n\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// OverlayImage.vue?3ffd0825","<template>\r\n  <div :class=\"['pixelParallel-rulers', {'pixelParallel-rulers-enabled': config.rulers.enabled}]\">\r\n    <div class=\"pixelParallel-ruler-x\" :style=\"{'margin-top': `${config.rulers.x}px`}\" v-draggable=\"{y: true, onDragEnd: handleXDragEnd}\"></div>\r\n    <div class=\"pixelParallel-ruler-y\" :style=\"{'margin-left': `${config.rulers.y}px`}\" v-draggable=\"{x: true, onDragEnd: handleYDragEnd}\"></div>\r\n  </div><!-- /.pixelParallel-rulers -->\r\n</template>\r\n\r\n<script>\r\n\r\nimport draggableDirective from './../directives/draggable.js';\r\n\r\nexport default {\r\n  name: 'overlay-rulers',\r\n\r\n  props: ['config'],\r\n\r\n  methods: {\r\n    handleXDragEnd (newPosition) {\r\n      this.config.rulers.x = newPosition.top;\r\n    },\r\n    handleYDragEnd (newPosition) {\r\n      this.config.rulers.y = newPosition.left;\r\n    }\r\n  },\r\n  directives: {\r\n    draggable: draggableDirective\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n  /*  Overlay - Rulers  */\r\n  .pixelParallel-rulers { position: relative; z-index: 2147483646; }\r\n  .pixelParallel-ruler-x,\r\n  .pixelParallel-ruler-y { display: none; position: fixed; top: 0; left: 0; z-index: 2; background: cyan; }\r\n  .pixelParallel-ruler-x:after,\r\n  .pixelParallel-ruler-y:after { content: ''; position: absolute; top: -8px; left: -8px; right: 0; bottom: 0; padding: 10px; }\r\n\r\n  .pixelParallel-ruler-x { right: 0; height: 1px; cursor: row-resize; }\r\n  .pixelParallel-ruler-y { bottom: 0; width: 1px; cursor: col-resize; }\r\n\r\n  /*  States  */\r\n  .pixelParallel-rulers-enabled .pixelParallel-ruler-x,\r\n  .pixelParallel-rulers-enabled .pixelParallel-ruler-y { display: block; }\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// OverlayRulers.vue?0e4a3114","<template>\r\n  <div :class=\"['pixelParallel-panel', {'pixelParallel-panel-minimized': config.minimized, 'pixelParallel-panel-dragging': this.dragging}]\" v-draggable=\"{x: true, y: true, onDragEnd: handleDragEnd, onDragMove: handleDragMove, onDragStart: handleDragStart}\" :style=\"panelInlineStyles\">\r\n\r\n    <div class=\"pixelParallel-panel-inner\">\r\n      <div class=\"pixelParallel-panel-handle\"></div><!-- /.pixelParallel-panel-handle -->\r\n\r\n      <iframe class=\"pixelParallel-panel-isolator\" frameborder=\"0\"></iframe>\r\n\r\n      <div :class=\"['pixelParallel-panel-content', {'pixelParallel-panel-content-minimized': config.minimized}]\">\r\n        <droparea title=\"Drop Here\" :on-upload=\"handleImageChange\" />\r\n\r\n        <header class=\"header\">\r\n          <div class=\"panel-control\">\r\n            <ul>\r\n              <li>\r\n                <a href=\"#\" :class=\"{'active': !config.visible}\" @click.prevent=\"config.visible = !config.visible\" title=\"Hide All Elements\"><i class=\"ico ico-eye-slash-small\"></i></a>\r\n              </li>\r\n\r\n              <li>\r\n                <a href=\"#\" @click.prevent=\"config.minimized = !config.minimized\">\r\n                  <i class=\"ico ico-minimize\"></i>\r\n\r\n                  <i class=\"ico ico-maximize\"></i>\r\n                </a>\r\n              </li>\r\n\r\n              <li>\r\n                <a href=\"#\" @click.prevent=\"handleCloseClick\"><i class=\"ico ico-close\"></i></a>\r\n              </li>\r\n            </ul>\r\n          </div><!-- /.panel-control -->\r\n\r\n          <nav class=\"nav\">\r\n            <ul>\r\n              <li :class=\"{'current': config.currentPane === 'image'}\">\r\n                <a href=\"#\" @click.prevent=\"setCurrentPane('image')\">Image</a>\r\n              </li>\r\n\r\n              <li :class=\"{'current': config.currentPane === 'grid'}\">\r\n                <a href=\"#\" @click.prevent=\"setCurrentPane('grid')\">Grid <span class=\"ad\">and Rulers</span></a>\r\n              </li>\r\n            </ul>\r\n          </nav><!-- /.nav -->\r\n        </header><!-- /.header -->\r\n\r\n\r\n        <div class=\"main\">\r\n          <div class=\"panes\">\r\n            <div class=\"pane\" v-if=\"config.currentPane === 'image'\">\r\n              <div class=\"row row-head row-head-large-gutter\">\r\n                <div class=\"col col-2-of-5\">\r\n                  <upload-button title=\"Upload Image\" :on-upload=\"handleImageChange\" />\r\n                </div><!-- /.col col-2-of-5 -->\r\n\r\n                <div class=\"col col-1-of-5\">\r\n                  <span class=\"elements-divider\">or</span>\r\n                </div><!-- /.col col-1-of-5 -->\r\n\r\n                <div class=\"col col-2-of-5\">\r\n                  <paste-box title=\"Paste Here\" :on-paste=\"handleImageChange\" />\r\n                </div><!-- /.col col-2-of-5 -->\r\n              </div><!-- /.row -->\r\n\r\n              <div class=\"row row-head\">\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.image.top\" title=\"Top\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.image.left\" title=\"Left\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.image.opacity\" title=\"Opacity\" :arrows=\"true\" :step=\".1\" :min=\"0\" :max=\"1\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.image.scale\" title=\"Scale\" :min=\"0\" :max=\"3\" :step=\".05\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n              </div><!-- /.row -->\r\n\r\n              <div class=\"row\">\r\n                <div class=\"col\">\r\n                  <div class=\"icon-link-group\">\r\n                    <a href=\"#\" class=\"icon-link\" :class=\"{'active': config.image.difference}\" @click.prevent=\"config.image.difference = !config.image.difference\">\r\n                      <i class=\"ico ico-color\"></i>\r\n\r\n                      <span class=\"text\">Color Diff</span>\r\n                    </a>\r\n\r\n                    <a href=\"#\" class=\"icon-link\" :class=\"{'active': config.image.lock}\" @click.prevent=\"config.image.lock = !config.image.lock\">\r\n                      <i class=\"ico ico-lock\"></i>\r\n\r\n                      <span class=\"text\">Lock</span>\r\n                    </a>\r\n\r\n                    <a href=\"#\" class=\"icon-link\" :class=\"{'active': !config.image.enabled}\" @click.prevent=\"config.image.enabled = !config.image.enabled\">\r\n                      <i class=\"ico ico-eye-slash\"></i>\r\n\r\n                      <span class=\"text\">Hide Image</span>\r\n                    </a>\r\n                  </div><!-- /.icon-link-group -->\r\n                </div><!-- /.col -->\r\n              </div><!-- /.row -->\r\n            </div><!-- /.pane -->\r\n\r\n            <div class=\"pane\" v-if=\"config.currentPane === 'grid'\">\r\n              <div class=\"row row-head\">\r\n                <div class=\"col col-1-of-3\">\r\n                  <toggle v-model=\"config.horizontalGrid.enabled\" title=\"Layout Grid\" />\r\n                </div><!-- /.col col-1-of-3 -->\r\n\r\n                <div class=\"col col-1-of-3\">\r\n                  <toggle v-model=\"config.verticalGrid.enabled\" title=\"Baseline Grid\" />\r\n                </div><!-- /.col col-1-of-3 -->\r\n\r\n                <div class=\"col col-1-of-3\">\r\n                  <toggle v-model=\"config.rulers.enabled\" title=\"Rulers\" :action=\"{text: '(reset)', handler: this.handleRulersReset}\" />\r\n                </div><!-- /.col col-1-of-3 -->\r\n              </div><!-- /.row -->\r\n\r\n              <div class=\"row row-head\">\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.horizontalGrid.width\" title=\"Width\" :min=\"0\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.horizontalGrid.columns\" title=\"Columns\" :min=\"0\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.horizontalGrid.gutter\" title=\"Gutter\" :min=\"0\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.horizontalGrid.opacity\" title=\"Opacity\" :arrows=\"true\" :step=\".1\" :min=\"0\" :max=\"1\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n              </div><!-- /.row -->\r\n\r\n              <div class=\"row\">\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.verticalGrid.gutter\" title=\"Baseline\" :min=\"1\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n\r\n                <div class=\"col col-1-of-4\">\r\n                  <number v-model=\"config.verticalGrid.opacity\" title=\"Opacity\" :arrows=\"true\" :step=\".1\" :min=\"0\" :max=\"1\" />\r\n                </div><!-- /.col col-1-of-4 -->\r\n              </div><!-- /.row -->\r\n            </div><!-- /.pane -->\r\n          </div><!-- /.panes -->\r\n        </div><!-- /.main -->\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport panelFonts from '../styles/panel-fonts.js';\r\nimport panelIcons from '../styles/panel-icons.js';\r\nimport panelStyles from '../styles/panel.js';\r\nimport Toggle from './Toggle.vue';\r\nimport Number from './Number.vue';\r\nimport UploadButton from './UploadButton.vue';\r\nimport Droparea from './Droparea.vue';\r\nimport PasteBox from './PasteBox.vue';\r\nimport draggableDirective from '../directives/draggable.js';\r\n\r\n\r\nconst dragPositions = {\r\n  start: {\r\n    x: 0,\r\n    y: 0\r\n  },\r\n  element: {\r\n    x: 0,\r\n    y: 0\r\n  },\r\n  last: {\r\n    x: 0,\r\n    y: 0\r\n  },\r\n  max: {\r\n    x: 0,\r\n    y: 0\r\n  }\r\n};\r\n\r\nexport default {\r\n  name: 'panel',\r\n\r\n  props: ['config', 'onImageChange', 'onDisableClick'],\r\n\r\n  data() {\r\n    return {\r\n      contentElement: null,\r\n      styleElement: null,\r\n      isolatorElement: null,\r\n      dragging: false\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.isolatorElement = this.$el.querySelector('.pixelParallel-panel-isolator');\r\n    this.contentElement = this.$el.querySelector('.pixelParallel-panel-content');\r\n    this.styleElement = document.createElement('style');\r\n\r\n    this.styleElement.textContent = panelFonts;\r\n    this.styleElement.textContent += panelIcons;\r\n    this.styleElement.textContent += panelStyles;\r\n\r\n    this.attach();\r\n\r\n    // Fix Firefox issue\r\n    this.isolatorElement.addEventListener('load', () => {\r\n      this.attach();\r\n    });\r\n  },\r\n\r\n  methods: {\r\n    handleDragEnd (newPosition, event) {\r\n      const elementBoundingRect = this.$el.getBoundingClientRect();\r\n      const windowSize = {\r\n        x: window.innerWidth,\r\n        y: window.innerHeight\r\n      };\r\n\r\n      let propNameX = null;\r\n      let propNameY = null;\r\n      let propValX = 0;\r\n      let propValY = 0;\r\n\r\n      if (dragPositions.last.x < windowSize.x / 2) {\r\n        propNameX = 'left';\r\n\r\n        propValX = dragPositions.last.x / window.innerWidth * 100;\r\n      } else {\r\n        propNameX = 'right';\r\n\r\n        this.$el.style.left = 'auto';\r\n        propValX = (windowSize.x - dragPositions.last.x - elementBoundingRect.width) / window.innerWidth * 100;\r\n      }\r\n\r\n      if (dragPositions.last.y < windowSize.y / 2) {\r\n        propNameY = 'top';\r\n\r\n        propValY = dragPositions.last.y / window.innerHeight * 100;\r\n      } else {\r\n        propNameY = 'bottom';\r\n\r\n        this.$el.style.top = 'auto';\r\n        propValY = (windowSize.y - dragPositions.last.y - elementBoundingRect.height) / window.innerHeight * 100;\r\n      }\r\n\r\n      this.$el.style.transform = 'none';\r\n      this.$el.style[propNameX] = propValX + '%';\r\n      this.$el.style[propNameY] = propValY + '%';\r\n\r\n      this.config.position.x.name = propNameX;\r\n      this.config.position.x.value = propValX;\r\n      this.config.position.y.name = propNameY;\r\n      this.config.position.y.value = propValY;\r\n\r\n      this.dragging = false;\r\n    },\r\n    handleDragMove (event) {\r\n      dragPositions.last.x = Math.min(dragPositions.max.x, Math.max(0, (dragPositions.element.x + event.screenX - dragPositions.start.x)));\r\n      dragPositions.last.y = Math.min(dragPositions.max.y, Math.max(0, (dragPositions.element.y + event.screenY - dragPositions.start.y)));\r\n\r\n      this.$el.style.transform = `translate(${dragPositions.last.x}px, ${dragPositions.last.y}px)`;\r\n    },\r\n    handleDragStart (event) {\r\n      const elementBoundingRect = this.$el.getBoundingClientRect();\r\n      dragPositions.start.x = event.screenX;\r\n      dragPositions.start.y = event.screenY;\r\n      dragPositions.element.x = elementBoundingRect.left;\r\n      dragPositions.element.y = elementBoundingRect.top;\r\n      dragPositions.max.x = window.innerWidth - elementBoundingRect.width;\r\n      dragPositions.max.y = window.innerHeight - elementBoundingRect.height;\r\n\r\n      this.$el.style.left = '0px';\r\n      this.$el.style.top = '0px';\r\n      this.$el.style.transform = `translate(${dragPositions.element.x}px, ${dragPositions.element.y}px)`;\r\n      this.$el.style.right = 'auto';\r\n      this.$el.style.bottom = 'auto';\r\n\r\n      this.dragging = true;\r\n    },\r\n    setCurrentPane(paneKey) {\r\n      this.config.currentPane = paneKey;\r\n    },\r\n    handleCloseClick() {\r\n      this.onDisableClick();\r\n    },\r\n    handleImageChange(imageObject) {\r\n      this.onImageChange(imageObject);\r\n    },\r\n    handleRulersReset() {\r\n      this.config.rulers.x = 10;\r\n      this.config.rulers.y = 10;\r\n    },\r\n    detach() {\r\n      this.$el.appendChild(this.contentElement);\r\n      this.$el.appendChild(this.styleElement);\r\n    },\r\n    attach() {\r\n      this.isolatorElement.contentDocument.body.appendChild(this.contentElement);\r\n      this.isolatorElement.contentDocument.head.appendChild(this.styleElement);\r\n\r\n      this.$children[0].setIsolatorDoc(this.isolatorElement.contentDocument);\r\n    }\r\n  },\r\n  computed: {\r\n    panelInlineStyles () {\r\n      const styleObject = {};\r\n\r\n      styleObject[this.config.position.x.name] = this.config.position.x.value + '%';\r\n      styleObject[this.config.position.y.name] = this.config.position.y.value + '%';\r\n      styleObject.opacity = 1;\r\n\r\n      return styleObject;\r\n    }\r\n  },\r\n  directives: {\r\n    draggable: draggableDirective\r\n  },\r\n  components: {\r\n    Toggle,\r\n    Number,\r\n    UploadButton,\r\n    Droparea,\r\n    PasteBox\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n  .pixelParallel-panel { position: fixed; right: 10px; bottom: 10px; z-index: 2147483647; width: 375px; height: 265px; transform: translate(0%, 0); background: #fff; transition: width 200ms ease-out, height 200ms ease-out; will-change: top, left, width, height, transform; opacity: 0; }\r\n\r\n  .pixelParallel-panel-inner { position: relative; overflow: hidden; height: 100%; border: 1px solid #dddedf; box-shadow: 0 2px 10px rgba(0,0,0,.1); box-sizing: border-box; }\r\n\r\n  .pixelParallel-panel-handle { position: absolute; top: -10px; right: -10px; z-index: 3; width: 20px; height: 20px; background: red; transform: rotate(45deg); background: linear-gradient(to top, transparent, transparent 50%, #ccc 50%, #ccc); background-size: 100% 2px; cursor: move; }\r\n\r\n  .pixelParallel-panel-isolator { border: 0; width: 100%; height: 100%; overflow: hidden; position: relative; }\r\n\r\n  .pixelParallel-panel-dragging .pixelParallel-panel-inner { pointer-events: none; }\r\n  .pixelParallel-panel-minimized { width: 112px; height: 50px; transition: width 200ms 150ms ease-out, height 200ms 150ms ease-out; }\r\n\r\n  @media (max-width: 395px) {\r\n    .pixelParallel-panel { right: 0; bottom: 0; width: 320px; }\r\n    .pixelParallel-panel-minimized { width: 112px; }\r\n  }\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// Panel.vue?07902458","<template>\r\n  <span class=\"paste-box mousetrap\" :title=\"title\" contenteditable=\"true\" @paste=\"pasteHandler\">\r\n  </span>\r\n</template>\r\n\r\n<script>\r\nimport utils from '../utils/utils.js';\r\n\r\nexport default {\r\n  name: 'upload-button',\r\n\r\n  props: ['title', 'onPaste'],\r\n\r\n  methods: {\r\n    pasteHandler(event) {\r\n      utils.getImageFromPasteEvent(event).then((result) => {\r\n        this.onPaste({\r\n          base64string: result.base64string,\r\n          type: result.type\r\n        });\r\n      });\r\n    }\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// PasteBox.vue?5b82f7f2","<template>\r\n  <label :class=\"['toggle', {'toggle-checked': checked}]\">\r\n    <span class=\"toggle-title\">{{title}} <a href=\"#\" v-if=\"action\" @click.prevent=\"action.handler\">{{action.text}}</a></span>\r\n\r\n    <input type=\"checkbox\" class=\"toggle-checkbox\" v-model=\"checked\">\r\n\r\n    <span class=\"toggle-main\">\r\n      <span class=\"toggle-handle\"></span>\r\n    </span>\r\n  </label>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'toggle',\r\n\r\n  props: ['title', 'action', 'value'],\r\n\r\n  computed: {\r\n    checked: {\r\n      get() {\r\n        return this.value;\r\n      },\r\n\r\n      set(val) {\r\n        this.$emit('input', val);   \r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// Toggle.vue?79bdbaf4","<template>\r\n  <span class=\"btn btn-block btn-file\">\r\n    {{title}}\r\n\r\n    <input type=\"file\" @change=\"changeHandler\">\r\n  </span>\r\n</template>\r\n\r\n<script>\r\nimport utils from '../utils/utils.js';\r\n\r\nexport default {\r\n  name: 'upload-button',\r\n\r\n  props: ['title', 'onUpload'],\r\n\r\n  methods: {\r\n    changeHandler(event) {\r\n      utils.getImageFromInputEvent(event).then((result) => {\r\n        this.onUpload({\r\n          base64string: result.base64string,\r\n          type: result.type\r\n        });\r\n      });\r\n    }\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// UploadButton.vue?12fa26e0","import Vue from 'vue';\r\nimport PixelParallel from './PixelParallel.vue';\r\n\r\nvar pixelParallelContainer = document.querySelector('#pixel-parallel-container');\r\n\r\nif (pixelParallelContainer === null) {\r\n\r\n  pixelParallelContainer = document.createElement('div');\r\n  pixelParallelContainer.id = 'pixel-parallel-container';\r\n\r\n  document.body.appendChild(pixelParallelContainer);\r\n\r\n  new Vue({\r\n    el: pixelParallelContainer,\r\n    render: h => h(PixelParallel)\r\n  });\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","export default `\r\n  /* latin */\r\n  @font-face {\r\n    font-family: 'Roboto';\r\n    font-style: normal;\r\n    font-weight: 400;\r\n    src: local('Roboto'), local('Roboto-Regular'), url(data:application/octet-stream;base64,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) format('woff2');\r\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;\r\n  }\r\n\r\n  @font-face {\r\n    font-family: 'Roboto';\r\n    font-style: normal;\r\n    font-weight: 500;\r\n    src: local('Roboto Medium'), local('Roboto-Medium'), url(data:application/octet-stream;base64,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) format('woff2');\r\n    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;\r\n  }\r\n`;\n\n\n// WEBPACK FOOTER //\n// ./src/styles/panel-fonts.js","export default `\r\n  .ico { display: inline-block; vertical-align: middle; background-repeat: no-repeat; background-size: contain; background-position: center center; }\r\n\r\n  .ico-eye-slash { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAaCAYAAADSbo4CAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4OTg4M0UyQ0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4OTg4M0UyREJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg5ODgzRTJBQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg5ODgzRTJCQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+U11e4gAABLFJREFUeNqsV29IZFUU31FzxP/mv9iiL5qKKZGuOoulKAVZbC1+MRKxdKXCzVBCDcQP6YK1sBEjflm1wLWWCkbZTysIhmu5tpPSfohcNpsRKR11ZpxJc8aZ2+88zrXnc1xn0As/3rxzzz3nd88957w7Z86c/rgIJAarLIRQcNrjFbINbALNgC5YIroQHWUCBuB54CyQBISzYytwAcgmRZ1OtwsHZ3nukUSCHbFAGzDPuw0Kra2tO3DSDOhOejS00w+BtUCOIiMjvRkZGZtJSUn/audSUlKEw+GAfUFkHj8JkWeAHwMRiIuLEwMDA2Jnh3wIMT09fUjHaDQKHp+xvY/YZkhEXgIcbNRXXFw8GxMT46f3hIQEMT8/r3iYmZkRnZ2dnvz8fLeaRFZWlvB4PKRiAxIgywf2ACfwarBE3gQ8HHrr5OTkr6Ojo/tOhoaGFBIgsHtUbphMJhmNy2yzALDQHBLYi+dbxxGhSCgOkpOT76+vrzvJWl1dnRKN+Ph4P+10YmLCfRSJ8vJySeJ34DHI4snw2NjYi0VFRX4m48PzjaOIUMm5SJ6WlvYAieZhgw8TExMXSF5WVqYISktLbwciAQdibm5OEqGmFgEY2VmB0+m0lpSUKLoRERG04ee0RCIBM8mio6P/QiR22dg0Z7yStJmZmWJhYcEFh78EIlJbWytJTPHm3gPu4D2eHSavrKyYUWmKPjb4J556NZEP5PkhAbfZ2CwnGo2bx/WMqKgoYbFYaJ0fKOIjWQ0LC/sa70bVMcROTU3dR/4p61AIV9REPucdb+/t7ZGxP4i9KncajyPS0dEho3GD11wheWNj4whkd9SJuLS09AQqS8nFpqYmqiy9JHIe0VASqbu7m5gYtJ0VvePIKklNTRU4f9m8noaMsA2bG1tbW2uQjWrsfULrwsPDxewsBV68v5+s1dXV92gSoaSyvait6YaGhi+PItLf3y+j0cfqIyRvb2+/xfJLKlO1gJ+juMrz1/aJbG5uvlBRUeHnjKZar9LUemxLS8u2lkROTo7wer1kbI2T8hw5QpSu453ybZ3WspkLsj3k5uY+9Pl8tI5OoORAH0FGf2EwGARHhshc1pBpQOkeIDI+Pi6j0cxqJqAJ7yMsf5vl7wJe7lEWu93u5/muQw0NLxE2m+0HZLLa2bdACqsYqFfIucrKSkniN1oLWRRVC36f4+q5xmu/kWvwgXywuroq28NtICxgi6eSReLdrampUZOxAx8DM1JGuWQ2myWR1zU2TIuLi/TV7uC1go/D7Ha7vbxmAUh85EePyAB3h4eHlc95oAStr6+XJCZ5mR54FtV1Sa/XUxTdqo7r6OnpmRX/j3tAalDXAEzEADc3NjZEW1vbARLovmJ5eZkMUrYV8P3UFqDlO6uqqqZQCA4Vie/Idsh3Vii809fXd+Aj19XVJY1+xWpX5Rx6gyM7O/tnROAnl8v1j4qAnWyd6PKMu8gN6Sg9PV2gSZFhcvIUq5Tn5eW9bLVaN8ThQdH4VObDiW/xvb291wsLC8Xg4KB00KMxdlXlnAh9TxFQ9ZDT+TsBxSGVo7+BOM08XUTOA0+G+v9jn4j8EQRe44xvDGFN0PhPgAEA6WDSgUWIcWAAAAAASUVORK5CYII=); width: 17px; height: 13px; }\r\n  a.active .ico-eye-slash { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAaCAYAAADSbo4CAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNTU1Mjc0RUJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNTU1Mjc0RkJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1NTUyNzRDQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1NTUyNzREQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+8eEv7QAABbtJREFUeNqsV3tQVFUcPvexd18IQgSEDYoKmI0gojyySRNEEzCcSglxMDSclAYJHLPUyT9K89U4ND4mRyscEnBKG5pJy5LC1MR1aqyYdCAJJ41EIB6y7O7t+909i8siiMaZ+WbPvfd3zv3Od36/754VQnf/y4a5pQOngJahBNe94qX9isNMYi7wGc0PrAKEoQ6U7/NF44F4IBoIBnwBCWgGGoA0HucLBjtUxj7hz4aFCGmXCywBJg+V8UtROnX9E/oX0d09dk+7eq/4wbaGVprPZd7hSUInMluIt3jLRy90ew70NQgsf6piQHc7V+2BFQkDPgISPB+YdQJ7PUFhz0/QyXqJ+db8ZWcLj3b1icmfprARipYexVCDtqYIOAZcvh9FkoDznIQjKkA6Z9IJmrQ0eVm6kS1+XMd+abKzrWetPRu+7+5wHxw6UmSZE3XU/Qd4G5gEbAFqgHlDVSQD+JiUh/R/fphqbGnqVONWf31be7h+usIm+otEwLr3olWhOI7etjZeYbJzeZugRit/fg0IgUbHsKJs9EsHUySJb4cOe3zpbLbZJ2GUNKmqwaap4aUI6oJwHatutHdwEv1aXLDEkkO1tf0O7AO8Acu+uYasyABRxUQyyJTg3rMDEYng9a88ZBSunFpsigAZmqTu5FX7zxQAJQRa6a7z1tN3I0EZsS5B3ysMrxTaGjY7VO44lGZsnBwoMdwUJZGV43aUJxGFS+VllNn1ExmmEOQCyVkNTGvrVjsp8EaHyn676Wi3XLc/fDci88NkhlVTtwokjuJ3OfkNnNMb1xYoGr1njsGCSmN2B1O89QIlr96dyApgClZkK0kz+kAJInYOSOUZT0bFrrY6WEp5p5fqNLM+DdXD1sRrc5IKa/iWbBIFbaymCua6GWgWZrz7tP4S8o9hgaNRCBvdiYylToiP2BMVKBnRrQdSeKJR++qe5hWpsGAvrVxLMY4qbi0QgBK3MzfieNY+aoQw+1Fv0UrXj/mLuS5ViEg5plCxYmNxjZUGZhJ7t/eUwTusA5HwMwps5RStcKi03qA1AQWYs3nDdGUOieke/9ShzpX1LQ5FQsDCCbI/buW4iJxJHitb6OL9C1YpYl97kMe72ueNk0sHIgIHpYqi7i4swLUVxtxo5QcsgPLpW7fwxeQC1Hl5svI3JS83T2fVbJmpX41SVR3YYQdjFbj1jPvLsK+vLp2k6/IkMe6OeTUB7wBT6WVQaT/8JBF9UvYwD6cP4gEqsDBfsa4oTglAn3agrJdI9IGO6p2JhuJoMERGy0iyz3E7z31vNz6pz4sJkvoQWQurl+6YVxt+36Tkr1lqpu8M5VsRjeUF8SlVKIqhoWKBMVR0HhDe4oVxx9CQ0YX75xm+QyYzKEOuVEz5A/hzMr+idHtJQEGWNEYzr1puXvTybJTrRb4F72FMJXMeBfaSi+MDeQX2EITSJRonuIp9nRWDbGA7vyTN8GPq+F7nf4F/qNYx5/nCOUjoZ142nqyaKn+0Ogpw7wYfm6Elgq9oOb3ENAaGSfbwE7AIMY5eQ/Q8KmJFPsT2SG1P7OYzVnbrdv+jxHMRMts2iwRg32CyRF6C45GcCT0ONRm1Rx83M3fc1oJYpTYvRonjwy9QDmJc06BHRe4fs+ABZSczTWxZVJ9vGoP7ssJYTQ0HN6+RQCNwqaNH/QAkSEUzCLTNDJGqLDlm5kbiCDDDReKe5xEE0qc9A2yPQ8pi1+qoLYtSWJDTvErIuvG7zZVH8IbW0T7i5fRw2ZYTqYvE8WEGH0YH6dcQf/CBjoo0EJMl8uRj/jCvFdGaQp0uP0CrDPcTTxxMMR5+xEvw4yXsaq08kTdjrpb/dWbt7FGzCmOVruP1tuVZOBDRCQ1tJyZu5CFVXy4ykSp+/LqZm9gXQAUv3+E5xa+KUUTAdUnVsNUjpJL7RANefO2B/oioOK4MESlADbDsPsYMGf8JMABPgCmUXqy07wAAAABJRU5ErkJggg==); }\r\n\r\n  .ico-eye-slash-small { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAWCAYAAADXYyzPAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNTU1Mjc1MkJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNTU1Mjc1M0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1NTUyNzUwQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1NTUyNzUxQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+OJ3L3AAABKJJREFUeNqsVglQlGUY/v6FBXZxggF2l6O4FllTMEZhUeSGAGW6hOFy0KRdjo7JYVCINMOIQQcDWqtpumvMY5ycRqSBDgLByakBPJJJC8HpUtwlNiBjr56X/iVsCZfwn3nme/9vv+99/vderuaFF9linud2VrM9tXVCrIaF3OMWS4xHDHwHfA1sxwf8YM8lRzuVOwFJgBJYBrgDQuAaL9/N4wZQfCeIvYEqoBDwmO+gg4ODRa0q8ocoB25rtWCe/W28gqetpBzH/SGXB5/OXJ/RFSKX/zT7QrQyipNKJOkQKxHzQECwUGI3oBVoBKYEAsHAdCDFYnNZiVqUvfGRGJFIFC8QcH4zQRaLWey6GBJv6vX6vVhbgE9A7m4vsQToAujLv1A/VtS4ZIkrxZQ99OADAk4gYK+89rrl2EfH2aXL389cio+LZS4uLiRqml4+cB3rr0Aa0Alyye2IKTtPACsdHR0/ePaZSqOzs3ONXv87B4sMS0PkrK2t/c/x8XFutgJPDw8WuXoViTdOdfdoSE9GelrmiuXLR0kXPNYKcvF8xOTaaKFQeKxqR0UEkiVNNzr6Df3g6urKLBYLuzI0fPPfClJSkhmUk7in48vOUqzByqhIp6yND/eGh4Uxs9kc6eTk9M5/ESdTGSB5LlSUbwuAonC8v9VysjWPfhwZGRHub2w2m0wmt9mXA/z92TJFKImXmjUHTmItDwwMmOS9l565IeM9mVTKpqamcl5qal4/FzERsZXhYVOwOAriQaAEiTIIyylmbHJy0iYR709NsYqVY2P6GnJ34aaCHLIaMMHSrb5+vuf/1h3+/FzEh2Gl/sK3F1cNDQ9T1qgRFxNWi5vbXa/OlRzkRl9fHxK7cPZHrJvc3d3fhdfKIU9/LPaVfX39CiSeae2aaCXv2VuIr8XFrjsCV7JDh4/64sI9Mx1E5l0L990SWyQfS05KJNECVAANQMeTj5cG8d1rEDoUfLIKUWpHKU/wrLBJroT4uF1JiQmTBoNBDOtPYyuS9i8ODJhysrOqKXtnNQsGT5D4IQioVV5Fje/GvQJKUuxRuDqpPOEVTczaNVmQtcARG2IcJqvzEDcksMUTW90UO+rTjc2abq1OZ9MsgGqgB4Nhs0QiqTUajZ21dfVU0KcAqaenZ4OqaGs+39cftYbApoGA/ARiUVWQn8fQnehwPXAZXnjTeiYxIZ6hvklswvmrIL2u0+kKUEoudfX7/FA+NO7Gke1VT5SVFPJNaTvfzeYfi1BWgSze29HZZent7ePggekP9PLyYqXFKqrbkfZPP1/91Zkzu7B9Lz+1aIKZkVzvY1j87C2TVfCW0pDZZ9d0giUNID+3ISP94NDQsJdWq53eT/2nWewGKQ0RNX/lPMqwLTcn+7fgoKDNeKfiptiogOMLGosgb4+IuC91YmKih5oXMpuFLg2hn2hovAHE+Ph4t+Tn5m5BP6dR+BRAMTADbwM7gV/+1zzu7z97Fp1HhhIcVChCpfz2DnyUkeoXQ2Q/1i1Wq/nyoXy4suh/ICXFKqojI//aAdLZSfIxcIgSEBhb0H8uav52PCKgDPgMOMfuwPOXAAMAFT2J6mINzK8AAAAASUVORK5CYII=); width: 15px; height: 11px; }\r\n  a.active .ico-eye-slash-small,\r\n  a:hover .ico-eye-slash-small { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAWCAYAAADXYyzPAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyRDhDQjlEQUJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyRDhDQjlEQkJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJEOENCOUQ4QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJEOENCOUQ5QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+rDemogAABJxJREFUeNqsVg1MVVUc/597373vvstLka8VCAoSkgoxgqeow2LxSM1a0/BrBi4/0mYWw8lYjjTdomnWWLoS/GKGtDZDCaYzDVLmtNqKlpVJ5gyFSKUejwfv4/Y7l/sYBCGEZ/vtfNxz/r/z/zyXRe/5m0bTmtZZKWavQ0LvHsk5NlpiNBX4CbgEbMIFrg7nkGmYwmXgCcAGxAOBgAS0GOPxBtqANfeD+EGgAFgBBA15M5G044vUKAwnAffUWhhi/VVDwEY/qcioMz1SbHgz3Vz/eJT4e98DuQkyiwsSsjDcDJ9PBISREo8FaoDdQLdJoMt8McjCfLWLVUuJXZkZqLB0gbEI/4FxCqP1ydzy5Lrp0IrRVwO1IA8cLnEoUA9kMaIzMN3uEJVxn9LODEWAxpRZ4dQ2nHLRmd88vYdeSZFpjJnxYcms8o5W9LcAO1AH8tB7EfPoPAEkKiYq/3Gt1fOATFtvOTQGbd1zokTadr6rq9Wpsb4CogMFWj5V17bt/a+7S7icotnm+U/Hmu5wWaJANSBXhyLmpp1uMdEnjS9akySB7Nfata/4h2ALI59G1HDD6/q3gM0zZDL1SNm262L3S+hjchIk+b1M5ZtnHzaR10cpqsQO/BdxBk8DgdH3l3IDJuCWCZiXFda5lvCPV277JNvBDp/bp/u/t9nCRbJH64nx8+zyjs/Q56VFiE6uNcyStX2O+VB8sEBOt5Y9/VDH3MGIORE9F2fqxu1SMTwCrEWgNCFNuM/ojkvrFw/c3oVp5l7Fmx3aVm7u8gWWbK414A2Q2MpHw8TGHtnSG4MRH4W5/jp+xZN8odn7C+ar4Rcveu0hq7BnsOB4BmZMDNOP12PvDfTLI8cIB2G1PIz1y2LdVnnZPRmB512dJNkMy/Yjbnk5Wa70+IhW1bjCcSDSv2FqiLAd5uvnW7OI2jhD1xaep3we9MDZz5eq0Ub1aoKMyUawSki1j3mccHEDgmtjqrwlzyY74Q8V2jdgKYWv11z1ePdmKYU8ev1tZaJM4VZd0Ecg4KXy+snFahHOLeNBijXurjqenrBKyZokeSHGfwKVA0omNregwC+RRVZVfKErGGLPQZ0iLijtcMc5l5G2SK3eYsHdzHucO4b+iy4v1U0rdSgYf8k1jQkUdn66UM0x6nqu3wUDCgjIT8AXBQfmW2ismfHNb/Gg7vRQqWbseS1VJqusa/su9l8Haeu1dt+ydy52K1M+dEQgfXbgmwPRXnB6qbrCKEqbjGo29LMIYfmI4mII0yp+cDPksH7B2HEC1WarhHT7Y0dD12Nl37q3YPkRXMOm9bxgPlS3w1WL1OYpIUK+oSl/ZN4e9nsMcjsIj9iPOkOa7vr0tdJ5CmVM0L2zHtrG8rw1tjciDU9+8JRyd9Z48QXM44DbwCrg2IieRQg+9Xy89GRbp3Ye0wBEtp+UPxr7gJnTQoXqsnmWnFCV8adwAw94rjWwH3gduPm//0BQeQLmTjI1ZU40hfEqhLYAl6o2rLKrr9ZG+pQCv476D6QmW+Vvsf8pOusnNVoVUMEDEGgf0T+XpmnD2WcB1gGnge/oPrR/BBgAJ8Z/uPblQXYAAAAASUVORK5CYII=); }\r\n\r\n  .ico-minimize { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAECAYAAACHtL/sAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNTU1Mjc1NkJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNzg5RUNEMEJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1NTUyNzU0QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1NTUyNzU1QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+scZqyQAAACJJREFUeNpibGxunclAAWAB4jRKDGBioBCAXDCLEgMAAgwAnRQDLht0cb4AAAAASUVORK5CYII=); width: 8px; height: 2px; }\r\n  a.active .ico-minimize,\r\n  a:hover .ico-minimize {  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAECAYAAACHtL/sAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyRDhDQjlENkJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyRDhDQjlEN0JBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE3ODlFQ0Q5QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE3ODlFQ0RBQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+0GRmFwAAACJJREFUeNpiVJz2eSYDBYAFiNMoMYCJgUIAcsEsSgwACDAAvYgDTxaOGksAAAAASUVORK5CYII=); }\r\n\r\n  .ico-maximize { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyRDhDQjlERUJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyRDhDQjlERkJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJEOENCOURDQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJEOENCOUREQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+IjlJQwAAADJJREFUeNpinDVn7n8GKgImBiqDwW8gCxYxRhLN+D/Cw3DUwFEDB2te/j8ahiQBgAADAF83BP0ZNeZfAAAAAElFTkSuQmCC); width: 10px; height: 10px; }\r\n  a.active .ico-maximize,\r\n  a:hover .ico-maximize { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBRTdEOTYyOUJBOUExMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBRTdEOTYyQUJBOUExMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJEOENCOUUwQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkFFN0Q5NjI4QkE5QTExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+rpUt2wAAADJJREFUeNpiVJz2+T8DFQETA5XB4DeQBYsYI4lm/B/hYThq4KiBgzUv/x8NQ5IAQIABAFs3BNTp9ScaAAAAAElFTkSuQmCC); }\r\n\r\n  .ico-close { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAUCAYAAACJfM0wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxNzg5RUNEM0JBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNzg5RUNENEJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE3ODlFQ0QxQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE3ODlFQ0QyQkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+0WmeEwAAAPtJREFUeNqU1UsKwjAQBuAY3HQnnsGz1F3VleJFfOxERE9SdaXSnXcRTyB01W6dyASGsUlmAj80TfoxNEPb2+0PhowF5AFpjX5kkAJydRNLFtaQM+SGm7ToHXKBrCg8hxzxeqzEPZrj/OQ8D1eQJ9ksxTlq0Kk83EBmSjyEOqeh71iDR1F+eFI8iXbBKXwoQUNwDH9J0BgcwgcSNAV7fAmp2f0a7zehB62gT0tWqa+8jPW5VTY/rTzH9UwDh1pqxN55ELcKdAr5dBxoJ24VaBvplj/cKlEjxSk8EaIpvOCw+0hvhWgI3/g/SJ9tdB/7t/L35PECi/uNrwADAPh2YLGNv80DAAAAAElFTkSuQmCC); width: 11px; height: 10px; }\r\n  a.active .ico-close,\r\n  a:hover .ico-close { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAUCAYAAACJfM0wAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxNzg5RUNEN0JBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxNzg5RUNEOEJBNzcxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjE3ODlFQ0Q1QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjE3ODlFQ0Q2QkE3NzExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Pl14FgAAAPxJREFUeNqU1UsKwjAQBuAY3HQn3kDwLHVXdaV4ER8X0BN4hKorle68i3gCoSC0WyeSgTB2kpnAD02TfgzN0PZGx48JxhJyh7RGPzJIAbm4iQ0WNpAT5Oo3adEb5AxZh/ACsvfXEyWOaO7nB+chXEEewWYpTlHjnQrhBjJX4hzqnCZ8xxo8itLDk+JJtAtO4UMJysEx/ClBYzCHDyRoCkZ8BanJ/drfb7gHraBPS1IpVl7G+twqmz+sPPfrmQbmWmpM3jmLWwU6g7w7DrQTtwq0jXTLH26VqJHiITwVoim8oLD7SO+EKIdv8Q/SJxvdx/6l/D0hXvjifuMrwADc6WDSaVwquAAAAABJRU5ErkJggg==); }\r\n\r\n  .ico-lock { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAcCAYAAAB/E6/TAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4OTg4M0UzMEJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4OTg4M0UzMUJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg5ODgzRTJFQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg5ODgzRTJGQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+ZGIeAgAAAfFJREFUeNpiZCAMZIE4BogdgFgaiFmA+DYQ7wHief/////MQCFgAuI6IP4GxP9x4NdAHAm0jIEQxgXYgHgVHguQ8T8griRkESMOiyYAcT6Mw8jIyGBra8tgZGTE8OvXL4aDBw8yXL16FVk9yMIIoIGrSAkyfSD+C3OxpKTk/0OHDv1HBv/+/fu/YMGC/2xsbHCfcXJyfgXSPKQE3RyYZhYWlv9nzpyBmw/EB4G4H4inAvGV2bNnowRjeHj4TFIsug/TGBYWBrPkGRDbooTV//+Mf/78SVBSUvoHUx8UFPQTKI7VV0xYLJKDMezs7EDUHyD2BcbTYWRFQD7Ixwv4+PiOw8QeP34MSkSRuJIwTjFBQUEQtQ5o6FlcEXrhwoWLMPaPHz9AlAuxFqGDQyTmP0VyLXpPokUc2ASR8xGoiHEDZT6YgK+vL8P79+83Hzly5Boeg0F6DEEMUVFRhpiYmFf9/f0OwARwHZtiFWik/6cSfgoKLWypTh2ImRmoB6R27Nhhgk3Cm4q+AeN37949B/qECV8+ogpgYmKSAFK8pKQ66lg8atGoRQNm0Xcq5yEGYDWPVY5VRkbmFFABxSUCqB1RUVEBq5n5MVpBQI4TkNpLRY+BqngeWGghxxGoqt4KVUAp+AXEXchRwoivFUlNABBgAMOih6y6PH/+AAAAAElFTkSuQmCC); width: 13px; height: 14px; }\r\n  a.active .ico-lock { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAcCAYAAAB/E6/TAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDM0E3NkI0QkJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDM0E3NkI0Q0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMzQTc2QjQ5QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMzQTc2QjRBQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+R5SWVwAAAglJREFUeNpiVJz2mYEAkAXiGCB2AGJpIGYB4ttAvAeI593L5CFoAAgw4rGICYhrgLgCiDlxqHkDxHlAy5YTsogJhzgbEK8A4kY8loCACBAvVZr+pZJci7qAOBTubSA2k2JmSNJjZYjRYWVQFULRBpJuBVoWRmrQ6QPxOZgjxLgYGSa7cTCYSjLDFfwH4nU3/zBUHfjB8PsfRIyDheHbjz8M4sBg/ILNIhYsYrkwS5iB5BwvTgYdUSaY+YdBjgB6gS1YncX+zz927coDP8GagJZw+aiw9AKZ6cRa5AxjeCiywCx5DsThwOA5DJMDupwxRIM1fvq53/MeffoHCj6Q7xKAVDEQfyEmjuRgDFC8AMEfIPZFtgQEgPz/qjO+LOBhYzgOE3v+5R8oEUUSmxjgYvzsYIeuAxp6FlckX3vz7yKM/fMvmHIhJdUhg0MMpAFFci16T6JFHIQSA6iIcUOW3HznD8OSq78jgEw9PAZbwBivv/1naDn2U3zexd+awMRyHVs+UgHiG6AUzUAd8AxURgIt+4cedOpUtAQEpBb4cJqQGkdkAX0xpo3I5tPMIiZGBgkgxUtzi8hJ3qMWjVpEG4u+UzkPMbAyMWK16LAED+NpNDmyACvQxDQDNlAbAmvp/ftYLDeo/baXih4DFai/sMURqKreClVAKfgFbbLBo4Tx////dEkMAAEGABHchhTziHgTAAAAAElFTkSuQmCC); }\r\n\r\n  .ico-color { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAeCAYAAABNChwpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDM0E3NkI0M0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDM0E3NkI0NEJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg5ODgzRTMyQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMzQTc2QjQyQkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+HF+mwQAAAyxJREFUeNq0l89rE0EUx2fTiDHEJhIJgaSGUlEUrA1IaTVIaaSH9qD0UE9SoT0oHopQCurB9GD7N0hQPHjxoF5SaSFgRKlSMNLcCorGaCGa/jDWqE3d8ftgt0yXbXa32Q58mGV3Zt53Zue9eSOxOgvnvK7+koW2AXAenAGt4CDYB1ZBHrwFU+AVRMnMxnIIJMFfmrAJPoBh4KTVMcJoda6BNZOGtcyBYzsVsAfcNzIiSZKRiB/gnFUBNPOHegPGYjGeTCb5wsIC39jY4H19fdyEyHXU3VYE3NQOEolE+MzMDNcWMwIIp9P5E3XEjIDjYF3s3NnZyUulkmj3JRgGRzC7KbN7IhgMzpkR8Fjs1NLSwldWVlTDn0CPpn3KysaMx+MXawk4CmRxg83OzqrG6cGv87ssCWhvb/9eS0BCbNzf368afw9823iLJQEOh4P20gVRgEMY7Kw48tDQEFM6XsJqrNoR0WRZZvl8PiG+EwVE1YeGhgbW1dVFj09h/LWdYbVQKLQqYX2LgL1gc5nD4TBzu930eI/ZXIrFIsWZmFaAS2zU2NhI1T+QsVvA2hpFdnZSK6AiNlpeXqbqC5a/YrcAZXJBrYAqjJXUl4uLiyTiF9uFQr8XxaO3CbNikjE9PR3cDQFtbW1UlfW+XRd9trubzg/uNRjPUhxwuVy8XC7TuLf0AlEI7ieLHUZGRibtFDAwMLB5jumeBR0dHW/EDn6/n7KgsB0CKLRns1ky/hvs1xUwNjZ2yuv1buno8Xi+oj5cr4DBwUF19o9q5gPj4+MvdGI4bZorlOftREBTUxOHV5FxGURrCsDL8Ojo6J9tBvsI7oAeZVXSRsZpRXO5nDr7B6ZyQqRblxOJhJmcrybwedH4Z3DAdFaMj5OpVIqHQqEdGafjHHFfNb4KTlhKy/FRArfht/LExAQPBAKmdjpOUZ5Op8UUrrCdccLwZkQ+i+putVoNZTIZhiyJzc/Ps6WlJVapVJjP52PNzc0sGo2y3t5ehgRW7P4EXAXf6r3/kd/eAEVuXGinPwdxMzcjyeLlki4slKmcVo5UyhPdyv2QPOQdeKbcFU2V/wIMAB8kuOEdlGYQAAAAAElFTkSuQmCC); width: 16px; height: 15px; }\r\n  a.active .ico-color { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAeCAYAAABNChwpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDM0E3NkI0N0JBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDM0E3NkI0OEJBNzYxMUU2QjcwQUM4MTUzRjQxOUU1QyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMzQTc2QjQ1QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMzQTc2QjQ2QkE3NjExRTZCNzBBQzgxNTNGNDE5RTVDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+EZEHUwAAA55JREFUeNq0l2lIVFEUx+9zVsdRI83GvaQQLbRcCrRlCikYiRYCESuKMpSkok8VRYKVfupDSCblgvTFghYliUIws7TFjISKpMLUNhU1dVzGmdf/vnkjz2mW95zxwI8Z7tx553/PPffc85jl10aJJ/Y1X+vR/+US5oaAnSAdJIBg4BtTNjaMz27QDh6CFoiyiH0oIyICUeA8OACUYoICikE1hMy4m+zjShw4Bj6AIyKdU4sBN8ALRCduvgIUoAKUAj9XCl1YKmiDiAypAuhzq8Ah+x9SQmWkWK8ijdka0pWnJfpotykUgIc1QMRWKUl4BuQIB8L9GXJ5s5psjJRJznIW0ZT5kAcQsRo50e0uAvGgUDiQtFRG6vZqhM5bQC6IbeqeaRAjwmwh2iUa5o6YCBTx+29N/wAfUpmpJgEqbrep+qNYyeO5CxRn/UY2dV/9RNatHb61ziIQC3YLE+FKhsrmvBUk2zmXbOPTXFI73YJsYWJvi5Fz4Yd9AQY4HyQeWme/OfhZj3mXMwGbhD9kxSlsId7PVzuPzYKn9Y1aCp0JWGv7IkMc1odxq78H563Ei/ZzjE3gy/ocASqwyDao0zLE15qeFcTLNjDB0m3eYC9ALZykVXKpYAZN3hYwbuIOTqK9AKNw0sgkN6kX4Td6W4C/dXE6ewEmDA/YBn+Ps2R4ih0nC2A6P06A1lESvhVWl+bvZt1CCIgP5lz+/U8AnD4STqz9aFqM2h3oTecqHKx11tPV6ygCt3H8Zktra5+ZFD2fOu1NARnL5MRPwW3BO0cC+hJCZK+Ef7j/eeYUPiK84Zy6zUvieppJusMOb0OEp4DPUs6GJlmlRsG8xNcVngrYEysnq6z7XwdGHQoo75h+czhR0SwcM5rYMB+GS9A8iU3srIWisJ1LV9nyu8RlR3Q8RZmTu0YxZVfD/fFRBrrAJXpX8VFRizn3lQZfEmi9VWtAh9uuGO3WwdL26aqrr6fFX/iOzjxWXgXnsUHcOnv4CjjktildeX2s+kSKsuSmQW0rHJJtO67zenRSvPMRkGnv3N2Lydkt0fLJJ9myCzWdJqbyvYkMTrBuM53eogXJSpIWMdvC0TNvoO3AvF5MUIyo8vIZCwlv+2Em7b/M5NOAhQxNsWQCFwvtmCLRutEM10fJuQZWYHdBPvjjyZsRFUGTsACcFN7lzhth8hRcBI1u6wPLSkoz2ibpQRqfUEFAA2jH9I3P8Aa+gRVl/wQYAICSAbXYakIpAAAAAElFTkSuQmCC); }\r\n`;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/styles/panel-icons.js","export default `\r\n  /* ------------------------------------------------------------ *\\\r\n    Pixel Parallel Panel\r\n  \\* ------------------------------------------------------------ */\r\n\r\n  * { padding: 0; margin: 0; outline: 0; border: 0; box-sizing: border-box; }\r\n\r\n  body { font-family: Roboto, Arial, Helvetica, sans-serif; font-size: 12px; line-height: 1; color: rgba(0,0,0,.85); overflow: hidden; font-weight: 500; }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Buttons\r\n  \\* ------------------------------------------------------------ */\r\n\r\n  .btn { display: inline-block; position: relative; overflow: hidden; background: #2196f3; padding: 0 15px; border-radius: 2px; font-size: 14px; line-height: 32px; color: #fff; text-transform: uppercase; text-decoration: none; text-align: center; cursor: pointer; transition: 200ms; }\r\n  .btn:hover { background: #2980b9; }\r\n  \r\n  .btn-block { display: block; width: 100%; padding-left: 0; padding-right: 0; }\r\n\r\n  .btn-success { background: #abdc28; }\r\n  .btn-success:hover { background: #9ac117; }\r\n\r\n  .btn-danger { background: #e85128; }\r\n  .btn-danger:hover { background: #e04a28; }\r\n\r\n  .btn[disabled] { background: #ccc; cursor: default; }\r\n\r\n  .btn-file input { position: absolute; left: 0; top: 0; width: 100%; height: 100%; opacity: 0.01; cursor: pointer; }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Grid\r\n  \\* ------------------------------------------------------------ */\r\n\r\n  .row { padding: 10px 15px; }\r\n  .row:after { content: ''; line-height: 0; display: table; clear: both; }\r\n\r\n  .row-head { border-bottom: 1px solid #ebebeb; padding-top: 10px; padding-bottom: 10px; margin-bottom: 10px; }\r\n  .row-head-large-gutter { padding-top: 21px; padding-bottom: 21px; }\r\n\r\n  .col { float: left; padding: 0 5px; display: table; width: 100%; }\r\n  .col-1-of-2 { width: 50%; }\r\n\r\n  .col-1-of-3 { width: 33.33%; }\r\n  .col-2-of-3 { width: 66.66%; }\r\n\r\n  .col-1-of-4 { width: 25%; }\r\n  .col-3-of-4 { width: 75%; }\r\n\r\n  .col-1-of-5 { width: 20%; }\r\n  .col-2-of-5 { width: 40%; }\r\n  .col-3-of-5 { width: 60%; }\r\n  .col-4-of-5 { width: 80%; }\r\n\r\n  @media (max-width: 372px) {\r\n    .row { padding-left: 5px; padding-right: 5px; }\r\n  }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Header\r\n  \\* ------------------------------------------------------------ */\r\n\r\n  .header { border-bottom: 1px solid #ebebeb; }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Panel Control\r\n  \\* ------------------------------------------------------------ */\r\n  \r\n  .panel-control { float: right; padding-right: 10px; }\r\n  .panel-control ul { list-style: none; }\r\n  .panel-control li { float: left; }\r\n  .panel-control li a { display: block; position: relative; height: 48px; width: 30px; line-height: 48px; text-align: center; }\r\n  .panel-control li a .ico { position: absolute; top: 50%; left: 50%; margin-top: -6px; margin-left: -5px; transition: 200ms; }\r\n  .panel-control li a .ico-minimize { margin-top: 1px; margin-left: -3px; }\r\n  .panel-control li a .ico-eye-slash-small { margin-left: -6px; }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Nav\r\n  \\* ------------------------------------------------------------ */\r\n  \r\n  .nav { overflow: hidden; margin-bottom: -1px; }\r\n  .nav ul { list-style: none outside none; overflow: hidden; }\r\n  .nav li { float: left; }\r\n  .nav li a { display: block; position: relative; height: 48px; padding: 0 20px; line-height: 50px; color: rgba(0,0,0,.5); font-size: 16px; text-decoration: none; text-transform: uppercase; transition: 200ms; }\r\n  .nav li a:after { content: ''; position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); width: 0; height: 2px; background: #2196f3; transition: 200ms; }\r\n  .nav li.current a { color: #2196f3; }\r\n  .nav li.current a:after { width: 100%; }\r\n  .nav li a:hover { color: #2196f3; }\r\n\r\n  @media (max-width: 372px) {\r\n    .nav li a .ad { display: none; }\r\n  }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Number\r\n  \\* ------------------------------------------------------------ */\r\n  \r\n  .number { display: block; }\r\n\r\n  .number .number-field { display: block; position: relative; }\r\n  \r\n  .number .number-arrows { position: absolute; top: 50%; right: 2px; width: 10px; height: 16px; margin-top: -8px; }\r\n  .number .number-arrow { position: absolute; font-size: 0; line-height: 0; color: #bdbdbd; cursor: pointer; transition: 200ms; }\r\n  .number .number-arrow:nth-child(1) { top: 0; left: 0; }\r\n  .number .number-arrow:nth-child(2) { bottom: 0; left: 0; }\r\n  .number .number-arrow-up { border-width: 0 5px 5px; border-style: none outset solid; border-left-color: transparent; border-right-color: transparent; }\r\n  .number .number-arrow-down { border-width: 5px 5px 0; border-style: solid outset none; border-left-color: transparent; border-right-color: transparent; }\r\n  .number .number-arrow:hover { color: #2196f3; }\r\n\r\n  .number .number-input { display: block; width: 100%; border: 0 none; border-bottom: 2px solid #bdbdbd; font-family: inherit; font-size: 14px; font-weight: inherit; line-height: 30px; color: rgba(0,0,0,.5); transition: 200ms; -moz-appearance: textfield; }\r\n  .number .number-input::-webkit-outer-spin-button,\r\n  .number .number-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }\r\n\r\n  .number:active .number-input,\r\n  .number .number-input:focus { border-color: #2196f3; outline: 0 none; color: rgba(0,0,0,.85); }\r\n\r\n  .number .number-arrows + .number-input { padding-right: 20px; }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Toggle\r\n  \\* ------------------------------------------------------------ */\r\n  \r\n  .toggle { display: block; cursor: pointer; padding-bottom: 1px; }\r\n  .toggle .toggle-checkbox { position: absolute; opacity: 0; z-index: -999; }\r\n  \r\n  .toggle .toggle-title { display: block; margin-bottom: 10px; }\r\n  .toggle .toggle-title a { text-decoration: underline; color: inherit; font-size: .9em; }\r\n\r\n  .toggle .toggle-main,\r\n  .toggle .toggle-handle { transition: 200ms; }\r\n\r\n  .toggle .toggle-main { display: block; position: relative; width: 40px; height: 14px; border-radius: 100px; background: #898989; }\r\n  .toggle .toggle-handle { position: absolute; top: -3px; left: 0; width: 20px; height: 20px; border-radius: 50%; background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,.2); transform: translateX(0%); }\r\n\r\n  .toggle-checked .toggle-main { background: #90caf9; }\r\n  .toggle-checked .toggle-handle { background: #2196f3; transform: translateX(100%); }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Icon Link\r\n  \\* ------------------------------------------------------------ */\r\n\r\n  .icon-link-group { margin: 0 -10px; }\r\n\r\n  .icon-link { display: inline-block; text-decoration: none; color: #000; opacity: .5; padding: 10px; transition: 200ms; font-weight: 400; text-transform: uppercase; }\r\n  .icon-link.active,\r\n  .icon-link:hover { opacity: 1; }\r\n  .icon-link.active { color: #2196f3; }\r\n\r\n  .icon-link .text { display: inline-block; vertical-align: middle; }\r\n  .icon-link .ico { transition: 200ms; margin-right: 5px; }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Paste Box\r\n  \\* ------------------------------------------------------------ */\r\n  \r\n  .paste-box { display: inline-block; position: relative; overflow: hidden; height: 32px; width: 100%; font-size: 0; line-height: 0; background: #fff; border: 2px dashed #2196f3; text-align: center; border-radius: 2px; vertical-align: middle; transition: 200ms; }\r\n  .paste-box > * { display: none; }\r\n  .paste-box:focus { border-style: solid; }\r\n  .paste-box:before { content: attr(title); display: block; line-height: 28px; font-size: 14px; text-transform: uppercase; color: #2196f3; }\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Elements Divider\r\n  \\* ------------------------------------------------------------ */\r\n  \r\n  .elements-divider { display: block; text-align: center; color: #000; text-transform: uppercase; padding: 10px 0; }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    Droparea\r\n  \\* ------------------------------------------------------------ */\r\n  \r\n  .droparea { display: none; position: absolute; top: 0; left: 0; z-index: 999; width: 100%; height: 100%; background: #fff; }\r\n  .droparea:after { content: ''; position: absolute; top: 10px; bottom: 10px; left: 10px; right: 10px; border: 4px dashed #2196f3; border-radius: 4px; }\r\n  .droparea input { position: absolute; top: 0; left: 0; z-index: 9; width: 100%; height: 100%; opacity: 0; }\r\n  .droparea .droparea-title { position: absolute; top: 50%; left: 0; right: 0; text-align: center; font-size: 26px; line-height: 30px; margin-top: -15px; color: #2196f3; font-weight: normal; }\r\n\r\n  .droparea.enabled { display: block; }\r\n\r\n\r\n  /* ------------------------------------------------------------ *\\\r\n    States\r\n  \\* ------------------------------------------------------------ */\r\n\r\n  .panel-control .ico-maximize { opacity: 0; }\r\n  \r\n  .nav,\r\n  .main { transition: 200ms 200ms; }\r\n\r\n  .pixelParallel-panel-content-minimized .nav,\r\n  .pixelParallel-panel-content-minimized .main { opacity: 0; transition: 200ms; }\r\n  .pixelParallel-panel-content-minimized .panel-control .ico-minimize { opacity: 0; transition: 200ms 200ms; }\r\n  .pixelParallel-panel-content-minimized .panel-control .ico-maximize { opacity: 1; transition: 200ms 200ms; }\r\n`;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/styles/panel.js","import PouchDB from 'pouchdb';\r\n\r\nexport default class DB {\r\n  constructor() {\r\n    this.dev = false;\r\n\r\n    this.db = new PouchDB('PixelParallel', {\r\n      auto_compaction: true,\r\n      revs_limit: 1\r\n    });\r\n\r\n    // this.db.destroy();\r\n  }\r\n\r\n  storageSet(options) {\r\n    const doc = options.doc;\r\n\r\n    return this.storageGet(options, true).then((response) => {\r\n      let rev = null;\r\n      let promise = null;\r\n\r\n      if (typeof response !== 'undefined') {\r\n        rev = response._rev;\r\n      }\r\n\r\n      doc._rev = rev;\r\n      doc._id = options.docId;\r\n\r\n      promise = this.db.put(doc);\r\n\r\n      return promise\r\n        .catch((err) => {\r\n          if (this.dev) {\r\n            console.info('Pixel Parallel:', err);\r\n          }\r\n        }).then(() => {\r\n          if (this.dev) {\r\n            this.db.info().then((result) => {\r\n              console.info('Pixel Parallel:', 'db-info', result);\r\n            }).catch((err) => {\r\n              if (this.dev) {\r\n                console.info('Pixel Parallel:', err);\r\n              }\r\n            });\r\n          }\r\n        });\r\n    });\r\n  }\r\n\r\n  storageGet(options) {\r\n    const promise = this.db.get(options.docId, {\r\n      attachments: !!options.includeAttachments\r\n    });\r\n\r\n    return promise\r\n      .catch((err) => {\r\n        if (err.message !== 'missing') {\r\n          if (this.dev) {\r\n            console.info('Pixel Parallel:', err);\r\n          }\r\n        }\r\n      });\r\n  }\r\n  setImage(imageObject) {\r\n    this.storageSet({\r\n      docId: 'base64string',\r\n      doc: {\r\n        _attachments: {\r\n          'overlay': {\r\n            data: imageObject.base64string.split(',').pop(),\r\n            content_type: imageObject.type\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  getImage() {\r\n    return new Promise((resolve, reject) => {\r\n      this.storageGet({docId: 'base64string', includeAttachments: true}).then((response) => {\r\n        if (response && '_attachments' in response && 'overlay' in response._attachments && response._attachments.overlay) {\r\n          const image = response._attachments.overlay;\r\n\r\n          resolve({\r\n            base64string: 'data:' + image.content_type + ';base64,' + image.data,\r\n            type: image.content_type\r\n          }, true);\r\n        } else {\r\n          reject();\r\n        }\r\n      });\r\n\r\n    });\r\n\r\n  }\r\n\r\n  setProps(props) {\r\n    this.storageSet({\r\n      docId: 'properties',\r\n      doc: Object.keys(props)\r\n        .filter(key => !key.match(/^_/))\r\n        .reduce((obj, key) => {\r\n          obj[key] = props[key];\r\n          return obj;\r\n        }, {})\r\n    });\r\n  }\r\n\r\n  getProps() {\r\n    return new Promise((resolve, reject) => {\r\n      this.storageGet({docId: 'properties'}).then((response) => {\r\n        if (typeof response !== 'undefined') {\r\n          resolve(response);\r\n        } else {\r\n          reject();\r\n        }\r\n      });\r\n    });\r\n\r\n  }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/db.js","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-02abf5a2!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/PixelParallel.vue\n// module id = 26\n// module chunks = 0","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".pixelParallel-image-outer{visibility:hidden;position:absolute;top:0;left:0;width:100%;overflow:hidden;max-width:100vw;min-height:100vh}.pixelParallel-image-inner{position:absolute;z-index:2147483646;left:50%;top:0;cursor:move;transform:translateX(-50%);transition:opacity .15s}.pixelParallel-image-inner img{width:auto;height:auto;max-width:none;max-height:none;vertical-align:top;margin:0;padding:0;position:relative;transform-origin:50% 0;top:-1px;border:1px dashed #333}.pixelParallel-image-inner img:not([src]),.pixelParallel-image-inner img[src=\\\"\\\"]{visibility:hidden}.pixelParallel-image-enabled{visibility:visible}.pixelParallel-image-difference{mix-blend-mode:difference}.pixelParallel-image-difference img{opacity:1!important}.pixelParallel-image-locked,.pixelParallel-image-no-image{pointer-events:none}.pixelParallel-image-locked .pixelParallel-image-inner img{top:0;border:0 none}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-21a808b9!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/OverlayImage.vue\n// module id = 27\n// module chunks = 0","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".pixelParallel-panel[data-v-54cb82b4]{position:fixed;right:10px;bottom:10px;z-index:2147483647;width:375px;height:265px;transform:translate(0);background:#fff;transition:width .2s ease-out,height .2s ease-out;will-change:top,left,width,height,transform;opacity:0}.pixelParallel-panel-inner[data-v-54cb82b4]{position:relative;overflow:hidden;height:100%;border:1px solid #dddedf;box-shadow:0 2px 10px rgba(0,0,0,.1);box-sizing:border-box}.pixelParallel-panel-handle[data-v-54cb82b4]{position:absolute;top:-10px;right:-10px;z-index:3;width:20px;height:20px;background:red;transform:rotate(45deg);background:linear-gradient(0deg,transparent,transparent 50%,#ccc 0,#ccc);background-size:100% 2px;cursor:move}.pixelParallel-panel-isolator[data-v-54cb82b4]{border:0;width:100%;height:100%;overflow:hidden;position:relative}.pixelParallel-panel-dragging .pixelParallel-panel-inner[data-v-54cb82b4]{pointer-events:none}.pixelParallel-panel-minimized[data-v-54cb82b4]{width:112px;height:50px;transition:width .2s ease-out .15s,height .2s ease-out .15s}@media (max-width:395px){.pixelParallel-panel[data-v-54cb82b4]{right:0;bottom:0;width:320px}.pixelParallel-panel-minimized[data-v-54cb82b4]{width:112px}}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-54cb82b4&scoped=true!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/Panel.vue\n// module id = 28\n// module chunks = 0","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".pixelParallel-rulers{position:relative;z-index:2147483646}.pixelParallel-ruler-x,.pixelParallel-ruler-y{display:none;position:fixed;top:0;left:0;z-index:2;background:cyan}.pixelParallel-ruler-x:after,.pixelParallel-ruler-y:after{content:\\\"\\\";position:absolute;top:-8px;left:-8px;right:0;bottom:0;padding:10px}.pixelParallel-ruler-x{right:0;height:1px;cursor:row-resize}.pixelParallel-ruler-y{bottom:0;width:1px;cursor:col-resize}.pixelParallel-rulers-enabled .pixelParallel-ruler-x,.pixelParallel-rulers-enabled .pixelParallel-ruler-y{display:block}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-72cc98cf!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/OverlayRulers.vue\n// module id = 29\n// module chunks = 0","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".pixelParallel-overlay{position:absolute;left:0;top:0;width:100%;text-align:center;white-space:nowrap;display:none}.pixelParallel-overlay-enabled{display:block}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-9780cf1c!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/Overlay.vue\n// module id = 30\n// module chunks = 0","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".pixelParallel-grids{position:relative;z-index:2147483646;pointer-events:none}.pixelParallel-grid-horizontal,.pixelParallel-grid-vertical{position:fixed;z-index:1;pointer-events:none;visibility:hidden}.pixelParallel-grid-horizontal{top:50%;left:50%;display:table;width:100vw;height:200vh;opacity:.5;table-layout:fixed;border-spacing:30px;transform:translate(-50%,-50%)}.pixelParallel-grid-horizontal span{display:table-cell;background:red;height:200vh}.pixelParallel-grid-vertical{top:0;left:0;width:100%;height:100%;background:linear-gradient(180deg,transparent,transparent 90%,blue 0,blue);background-size:100% 10px;opacity:.5}.pixelParallel-grid-horizontal-enabled,.pixelParallel-grid-vertical-enabled{visibility:visible}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-b944b76a!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/OverlayGrids.vue\n// module id = 31\n// module chunks = 0","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  try {\n    return exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (typeof process !== 'undefined' && 'env' in process) {\n    return process.env.DEBUG;\n  }\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/debug/src/browser.js\n// module id = 32\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/debug/src/debug.js\n// module id = 33\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 34\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inherits/inherits_browser.js\n// module id = 35\n// module chunks = 0","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lie/lib/browser.js\n// module id = 36\n// module chunks = 0","/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.1\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n\n        // This needs to use a string cause otherwise since 0 is falsey\n        // mousetrap will never fire for numpad 0 pressed as part of a keydown\n        // event.\n        //\n        // @see https://github.com/ccampbell/mousetrap/pull/258\n        _MAP[i + 96] = i.toString();\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (typeof define === 'function' && define.amd) {\n        define(function() {\n            return Mousetrap;\n        });\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/mousetrap/mousetrap.js\n// module id = 37\n// module chunks = 0","/**\n * adds a pause and unpause method to Mousetrap\n * this allows you to enable or disable keyboard shortcuts\n * without having to reset Mousetrap and rebind everything\n */\n/* global Mousetrap:true */\n(function(Mousetrap) {\n    var _originalStopCallback = Mousetrap.prototype.stopCallback;\n\n    Mousetrap.prototype.stopCallback = function(e, element, combo) {\n        var self = this;\n\n        if (self.paused) {\n            return true;\n        }\n\n        return _originalStopCallback.call(self, e, element, combo);\n    };\n\n    Mousetrap.prototype.pause = function() {\n        var self = this;\n        self.paused = true;\n    };\n\n    Mousetrap.prototype.unpause = function() {\n        var self = this;\n        self.paused = false;\n    };\n\n    Mousetrap.init();\n}) (Mousetrap);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/mousetrap/plugins/pause/mousetrap-pause.js\n// module id = 38\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ms/index.js\n// module id = 39\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(require('lie'));\nvar getArguments = _interopDefault(require('argsarray'));\nvar events = require('events');\nvar inherits = _interopDefault(require('inherits'));\nvar nextTick = _interopDefault(require('immediate'));\nvar debug = _interopDefault(require('debug'));\nvar Md5 = _interopDefault(require('spark-md5'));\nvar vuvuzela = _interopDefault(require('vuvuzela'));\n\n/* istanbul ignore next */\nvar PouchPromise$1 = typeof Promise === 'function' ? Promise : lie;\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new PouchPromise$1(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise$1.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise$1.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise$1(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\ninherits(Changes, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (console !== 'undefined' && method in console) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function (fun) {\n    return fun.name;\n  };\n} else {\n  res = function (fun) {\n    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n  };\n}\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 events.EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* jshint maxlen: false */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise$1(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\n// BEGIN Math.uuid.js\n\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. \n *   // (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\nvar chars = (\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n  'abcdefghijklmnopqrstuvwxyz'\n).split('');\nfunction getValue(radix) {\n  return 0 | Math.random() * radix;\n}\nfunction uuid(len, radix) {\n  radix = radix || chars.length;\n  var out = '';\n  var i = -1;\n\n  if (len) {\n    // Compact form\n    while (++i < len) {\n      out += chars[getValue(radix)];\n    }\n    return out;\n  }\n    // rfc4122, version 4 form\n    // Fill in random data.  At i==19 set the high bits of clock sequence as\n    // per rfc4122, sec. 4.1.5\n  while (++i < 36) {\n    switch (i) {\n      case 8:\n      case 13:\n      case 18:\n      case 23:\n        out += '-';\n        break;\n      case 19:\n        out += chars[(getValue(16) & 0x3) | 0x8];\n        break;\n      default:\n        out += chars[getValue(16)];\n    }\n  }\n\n  return out;\n}\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\ninherits(Changes$2, events.EventEmitter);\n\nfunction tryCatchInChangeListener(self, change) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$2(db, opts, callback) {\n  events.EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change);\n  };\n\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$2.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$2.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$2.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.normalize(opts);\n    if (PouchDB$5._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB$5._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn',\n          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n          'but pouchdb-changes-filter plugin is not installed, so it ' +\n          'was ignored. Please install the plugin to enable filtering.'\n        );\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      callback(err || results[0]);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysQuery(api, opts, callback) {\n  var keys =  ('limit' in opts) ?\n      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  if (opts.descending) {\n    keys.reverse();\n  }\n  if (!keys.length) {\n    return api._allDocs({limit: 0}, callback);\n  }\n  var finalResults = {\n    offset: opts.skip\n  };\n  return PouchPromise$1.all(keys.map(function (key) {\n    var subOpts = $inject_Object_assign({key: key, deleted: 'ok'}, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new PouchPromise$1(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || {key: key, error: 'not_found'});\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, events.EventEmitter);\n\nfunction AbstractPouchDB() {\n  events.EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  if (typeof this._put === 'function' && opts.new_edits !== false) {\n    this._put(doc, opts, cb);\n  } else {\n    this.bulkDocs({docs: [doc]}, opts, yankError(cb));\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev) {\n      addToMissing(id, rev);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev) {\n      if (height[rev] > maxHeight) {\n        candidates.push(rev);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n        revs.push(rev);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise$1.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev) {\n            return rev.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev) {\n          pos--;\n          return {\n            rev: pos + '-' + rev.id,\n            status: rev.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (!isRemote(this)) {\n      return allDocsKeysQuery(this, opts, callback);\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$2(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise$1.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue$1() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue$1.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue$1.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue$1.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue$1.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB$5.adapters;\n  var preferredAdapters = PouchDB$5.preferredAdapters;\n  var prefix = PouchDB$5.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  var destructionListeners = self.constructor._destructionListeners;\n\n  function onDestroyed() {\n    self.removeListener('closed', onClosed);\n    self.constructor.emit('destroyed', self.name);\n  }\n\n  function onConstructorDestroyed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.removeListener('closed', onClosed);\n    self.emit('destroyed');\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    destructionListeners.delete(self.name);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n\n  // in setup.js, the constructor is primed to listen for destroy events\n  if (!destructionListeners.has(self.name)) {\n    destructionListeners.set(self.name, []);\n  }\n  destructionListeners.get(self.name).push(onConstructorDestroyed);\n}\n\ninherits(PouchDB$5, AbstractPouchDB);\nfunction PouchDB$5(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB$5)) {\n    return new PouchDB$5(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB$5.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB$5.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB$5.adapters[opts.adapter] ||\n      !PouchDB$5.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue$1();\n\n  self.adapter = opts.adapter;\n\n  PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB$5.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\nPouchDB$5.adapters = {};\nPouchDB$5.preferredAdapters = [];\n\nPouchDB$5.prefix = '_pouch_';\n\nvar eventEmitter = new events.EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n    if (typeof events.EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    destructListeners.get(name).forEach(function (callback) {\n      callback();\n    });\n    destructListeners.delete(name);\n  });\n}\n\nsetUpEventEmitter(PouchDB$5);\n\nPouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB$5.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB$5.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB$5.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB$5);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \\\"' + obj + '\\\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB$5.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB$5.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB$5;\n};\n\nPouchDB$5.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB$5.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB$5);\n\n  PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();\n  Object.keys(PouchDB$5).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB$5[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.2.0\";\n\nfunction debugPouch(PouchDB) {\n  PouchDB.debug = debug;\n  var logs = {};\n  /* istanbul ignore next */\n  PouchDB.on('debug', function (args) {\n    // first argument is log identifier\n    var logId = args[0];\n    // rest should be passed verbatim to debug module\n    var logArgs = args.slice(1);\n    if (!logs[logId]) {\n      logs[logId] = debug('pouchdb:' + logId);\n    }\n    logs[logId].apply(null, logArgs);\n  });\n}\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue$1(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue$1(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    if (isDesignDoc(doc)) {\n      return false;\n    }\n\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction isDesignDoc(doc) {\n  return /^_design\\//.test(doc._id);\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw 'Selector error: expected a JSON object';\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler$$1, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler$$1.db);\n}\n\nfunction filter(changesHandler$$1, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler$$1.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler$$1.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler$$1.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler$$1.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler$$1.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler$$1.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler$$1.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(debugPouch);\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(applyChangesFilterPlugin);\n\nPouchDB$5.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev) {\n  if (!/^\\d+\\-./.test(rev)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev.indexOf('-');\n  var left = rev.substring(0, idx);\n  var right = rev.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = uuid(32, 16).toLowerCase();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob$$1, start, end) {\n  if (blob$$1.webkitSlice) {\n    return blob$$1.webkitSlice(start, end);\n  }\n  return blob$$1.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob$$1, start, end, callback) {\n  if (start > 0 || end < blob$$1.size) {\n    // only slice blob if we really need to\n    blob$$1 = sliceBlob(blob$$1, start, end);\n  }\n  readAsArrayBuffer(blob$$1, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise$1.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise$1.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise$1(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler$$1 = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler$$1.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n  //    perhaps they are filtering on a per-doc basis)\n  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n  var keyRangeError = keyRange && keyRange.error;\n  if (keyRangeError && !(keyRangeError.name === \"DataError\" &&\n      keyRangeError.code === 0)) {\n    // DataError with error code 0 indicates start is less than end, so\n    // can just do an empty query. Else need to throw\n    return callback(createError(IDB_ERROR,\n      keyRangeError.name, keyRangeError.message));\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (opts.deleted === 'ok') {\n      results.push(row);\n      // deleted docs are okay with \"keys\" requests\n      if (deleted) {\n        row.value.deleted = true;\n        row.doc = null;\n      } else if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    } else if (!deleted && skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    callback(null, {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    });\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise$1(function (resolve) {\n    var blob$$1 = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n// before calling the next one. This works around IE/Edge race conditions in IDB.\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler$$1.addListener(dbName, id, api, opts);\n    changesHandler$$1.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler$$1.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n  var returnDocs;\n  if ('return_docs' in opts) {\n    returnDocs = opts.return_docs;\n  } else if ('returnDocs' in opts) {\n    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n    returnDocs = opts.returnDocs;\n  } else {\n    returnDocs = true;\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return opts.complete(filtered);\n      }\n\n      if (filtered) {\n        numResults++;\n        if (returnDocs) {\n          results.push(change);\n        }\n        // process the attachment immediately\n        // for the benefit of live listeners\n        if (opts.attachments && opts.include_docs) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              opts.onChange(change);\n            });\n          });\n        } else {\n          opts.onChange(change);\n        }\n      }\n    }\n\n    function onBatchDone() {\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        processMetadataAndWinningDoc(metadata, winningDoc);\n      }\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev;\n      if (!opts.rev) {\n        rev = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler$$1.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // some outdated implementations of IDB that appear on Samsung\n  // and HTC Android devices <4.4 are missing IDBKeyRange\n  return !isSafari && typeof indexedDB !== 'undefined' &&\n    typeof IDBKeyRange !== 'undefined';\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch (err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nvar IDBPouch = function (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n};\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new ExportedSet();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^\\(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      var rev = docInfo.metadata.rev;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev$$1, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: rev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new ExportedMap();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB$1(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = $inject_Object_assign(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch$1(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = $inject_Object_assign({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB$1(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  function getMaxSeq(tx, callback) {\n    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n    tx.executeSql(sql, [], function (tx, res) {\n      var updateSeq = res.rows.item(0).seq || 0;\n      callback(updateSeq);\n    });\n  }\n\n  function countDocs(tx, callback) {\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      callback(result.rows.item(0).num);\n    });\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    var seq;\n    var docCount;\n    db.readTransaction(function (tx) {\n      getMaxSeq(tx, function (theSeq) {\n        seq = theSeq;\n      });\n      countDocs(tx, function (theDocCount) {\n        docCount = theDocCount;\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: seq,\n        websql_encoding: encoding\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  function latest$$1(tx, id, rev, callback, finish) {\n    var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n    var sqlArgs = [id];\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var err = createError(MISSING_DOC, 'missing');\n        return finish(err);\n      }\n      var item = results.rows.item(0);\n      var metadata = safeJsonParse(item.metadata);\n      callback(latest(rev, metadata));\n    });\n  }\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish(err) {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n\n    if (!opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    } else if (opts.latest) {\n      latest$$1(tx, id, opts.rev, function (latestRev) {\n        opts.latest = false;\n        opts.rev = latestRev;\n        api._get(id, opts, callback);\n      }, finish);\n      return;\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    }\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var missingErr = createError(MISSING_DOC, 'missing');\n        return finish(missingErr);\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        var deletedErr = createError(MISSING_DOC, 'deleted');\n        return finish(deletedErr);\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n\n    var sqlArgs = [];\n    var criteria = [];\n\n    if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (opts.deleted !== 'ok') {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n      // count the docs in parallel to other operations\n      countDocs(tx, function (docCount) {\n        totalRows = docCount;\n      });\n\n      if (limit === 0) {\n        return;\n      }\n\n      // do a single query to fetch the documents\n      var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        criteria,\n        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n        );\n      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var item = result.rows.item(i);\n          var metadata = safeJsonParse(item.metadata);\n          var id = metadata.id;\n          var data = unstringifyDoc(item.data, id, item.rev);\n          var winningRev$$1 = data._rev;\n          var doc = {\n            id: id,\n            key: id,\n            value: {rev: winningRev$$1}\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev$$1;\n            if (opts.conflicts) {\n              var conflicts = collectConflicts(metadata);\n              if (conflicts.length) {\n                doc.doc._conflicts = conflicts;\n              }\n            }\n            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n          }\n          if (item.deleted) {\n            if (opts.deleted === 'ok') {\n              doc.value.deleted = true;\n              doc.doc = null;\n            } else {\n              continue;\n            }\n          }\n          results.push(doc);\n        }\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = thisBtoa(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev = pos + '-' + revHash;\n          if (revs.indexOf(rev) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var _opts = $inject_Object_assign({\n    websql: openDB\n  }, opts);\n\n  WebSqlPouch$1.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nvar WebSqlPouch = function (PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n};\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise$1(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise$1.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  }).catch(function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body &&\n      options.processData &&\n      typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      result.status = response.statusCode;\n      callback(result);\n    }\n  }).catch(function (error) {\n    if (!error) {\n      // this happens when the listener is canceled\n      error = new Error('canceled');\n    }\n    callback(error);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function () {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function () {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = {abort: abortReq};\n\n  var cleanUp = function () {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if (xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch (e) {}\n      }\n      err.status = xhr.status;\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax$1(options, callback) {\n  if (!false && (hasXhr || options.xhr)) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\nvar res$2 = function () {};\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore$1(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = $inject_Object_assign(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      res$2(obj, resp);\n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax$1(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = (isSafari ||\n    ((isIE || isEdge) && opts.method === 'GET'));\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore$1(opts, callback);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new PouchPromise$1(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var atts = row.doc && row.doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$2(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise$1.resolve();\n  }\n\n  return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise$1(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = thisBtoa(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax;\n\n  function ajax$$1(userOpts, options, callback) {\n    var reqAjax = userOpts.ajax || {};\n    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n    var defaultHeaders = clone(ajaxOpts.headers || {});\n    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,\n      options.headers || {});\n    /* istanbul ignore if */\n    if (api.constructor.listeners('debug').length) {\n      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n    }\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      ajax$$1(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise$1.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise$1.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise$1.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ajax$$1({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid$$1 = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    });\n  });\n\n  api.request = adapterFun$$1('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax$$1({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax$$1(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      ajax$$1(opts, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, cb);\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'latest']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax$$1({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    }).catch(callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob$$1) {\n          if (opts.binary) {\n            return blob$$1;\n          }\n          return new PouchPromise$1(function (resolve) {\n            blobToBase64(blob$$1, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetch(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise$1.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise$1.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    }).catch(callback);\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax$$1(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax$$1(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n\n    ajax$$1({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$1('putAttachment', function (docId, attachmentId, rev, blob$$1,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob$$1;\n      blob$$1 = rev;\n      rev = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    if (typeof blob$$1 === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob$$1);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob$$1 = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob$$1,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax$$1({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));\n    }).then(function () {\n      // Update/create the documents\n      ajax$$1(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$2(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax$$1(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    }).catch(callback);\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n    opts.timeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // We give a 5 second buffer for CouchDB changes to respond with\n    // an ok timeout (if a timeout it set)\n    var params = opts.timeout ? {timeout: opts.timeout - (5 * 1000)} : {};\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    } else if (opts.continuous) {\n      // Default heartbeat to 10 seconds\n      params.heartbeat = 10000;\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: opts.timeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax$$1(opts, xhrOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax$$1(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax$$1(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nvar HttpPouch$1 = function (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n};\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue$2() {\n  this.promise = new PouchPromise$1(function (fulfill) {fulfill(); });\n}\nTaskQueue$2.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$2.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$2();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return PouchPromise$1.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return PouchPromise$1.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return PouchPromise$1.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$2();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$2();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        return fetchFromView(viewOpts);\n      });\n      return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return PouchPromise$1.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = PouchPromise$1.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  if (builtInReduce[reduceFun]) {\n    return builtInReduce[reduceFun];\n  } else {\n    return evalFunctionWithEval(reduceFun.toString());\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev) {\n  return /^1-/.test(rev);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise$1.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise$1.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return PouchPromise$1.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  return updateCheckpoint(this.target, this.id, checkpoint,\n    session, this.returnValue);\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  var self = this;\n  if (this.readOnlySource) {\n    return PouchPromise$1.resolve(true);\n  }\n  return updateCheckpoint(this.src, this.id, checkpoint,\n    session, this.returnValue)\n    .catch(function (err) {\n      if (isForbiddenError(err)) {\n        self.readOnlySource = true;\n        return true;\n      }\n      throw err;\n    });\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.readOnlySource) {\n      return PouchPromise$1.resolve(targetDoc.last_seq);\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.readOnlySource = true;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new PouchPromise$1(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise$1.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n      checkpointer = new Checkpointer(src, target, repId, returnValue);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, events.EventEmitter);\nfunction Replication() {\n  events.EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, events.EventEmitter);\nfunction sync$1(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise$1.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync$1;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      return {\n        from: function (other, opts, callback) {\n          return self.constructor.replicate(other, self, opts, callback);\n        },\n        to: function (other, opts, callback) {\n          return self.constructor.replicate(self, other, opts, callback);\n        }\n      };\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB$5.plugin(IDBPouch)\n  .plugin(WebSqlPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\nmodule.exports = PouchDB$5;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb/lib/index-browser.js\n// module id = 40\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 41\n// module chunks = 0","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spark-md5/spark-md5.js\n// module id = 42\n// module chunks = 0","var Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./Droparea.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-7afe2c4a!../../node_modules/vue-loader/lib/selector?type=template&index=0!./Droparea.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Droparea.vue\n// module id = 43\n// module chunks = 0","var Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./Number.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-7b8b1e97!../../node_modules/vue-loader/lib/selector?type=template&index=0!./Number.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Number.vue\n// module id = 44\n// module chunks = 0","\n/* styles */\nrequire(\"!!vue-style-loader!css-loader?minimize!../../node_modules/vue-loader/lib/style-rewriter?id=data-v-9780cf1c!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./Overlay.vue\")\n\nvar Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./Overlay.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-9780cf1c!../../node_modules/vue-loader/lib/selector?type=template&index=0!./Overlay.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Overlay.vue\n// module id = 45\n// module chunks = 0","\n/* styles */\nrequire(\"!!vue-style-loader!css-loader?minimize!../../node_modules/vue-loader/lib/style-rewriter?id=data-v-b944b76a!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./OverlayGrids.vue\")\n\nvar Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./OverlayGrids.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-b944b76a!../../node_modules/vue-loader/lib/selector?type=template&index=0!./OverlayGrids.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/OverlayGrids.vue\n// module id = 46\n// module chunks = 0","\n/* styles */\nrequire(\"!!vue-style-loader!css-loader?minimize!../../node_modules/vue-loader/lib/style-rewriter?id=data-v-21a808b9!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./OverlayImage.vue\")\n\nvar Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./OverlayImage.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-21a808b9!../../node_modules/vue-loader/lib/selector?type=template&index=0!./OverlayImage.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/OverlayImage.vue\n// module id = 47\n// module chunks = 0","\n/* styles */\nrequire(\"!!vue-style-loader!css-loader?minimize!../../node_modules/vue-loader/lib/style-rewriter?id=data-v-72cc98cf!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./OverlayRulers.vue\")\n\nvar Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./OverlayRulers.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-72cc98cf!../../node_modules/vue-loader/lib/selector?type=template&index=0!./OverlayRulers.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/OverlayRulers.vue\n// module id = 48\n// module chunks = 0","\n/* styles */\nrequire(\"!!vue-style-loader!css-loader?minimize!../../node_modules/vue-loader/lib/style-rewriter?id=data-v-54cb82b4&scoped=true!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./Panel.vue\")\n\nvar Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./Panel.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-54cb82b4!../../node_modules/vue-loader/lib/selector?type=template&index=0!./Panel.vue\"),\n  /* scopeId */\n  \"data-v-54cb82b4\",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Panel.vue\n// module id = 49\n// module chunks = 0","var Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./PasteBox.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-45f08ef4!../../node_modules/vue-loader/lib/selector?type=template&index=0!./PasteBox.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/PasteBox.vue\n// module id = 50\n// module chunks = 0","var Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./Toggle.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-601c0122!../../node_modules/vue-loader/lib/selector?type=template&index=0!./Toggle.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Toggle.vue\n// module id = 51\n// module chunks = 0","var Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./UploadButton.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler?id=data-v-243bab3e!../../node_modules/vue-loader/lib/selector?type=template&index=0!./UploadButton.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/UploadButton.vue\n// module id = 52\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"pixelParallel\"\n    }\n  }, [_c('panel', {\n    attrs: {\n      \"config\": _vm.config,\n      \"on-image-change\": _vm.handleImageChange,\n      \"on-disable-click\": _vm.handleDisableClick\n    }\n  }), _vm._v(\" \"), _c('overlay', {\n    attrs: {\n      \"config\": _vm.config,\n      \"image\": _vm.image\n    }\n  })], 1)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-02abf5a2!./~/vue-loader/lib/selector.js?type=template&index=0!./src/PixelParallel.vue\n// module id = 53\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    class: _vm.imageOuterClasses,\n    style: ({\n      'height': (_vm.imageOuterHeight + \"px\")\n    })\n  }, [_c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: ({\n        x: true,\n        y: true,\n        onDragEnd: _vm.handleDragEnd\n      }),\n      expression: \"{x: true, y: true, onDragEnd: handleDragEnd}\"\n    }],\n    staticClass: \"pixelParallel-image-inner\",\n    style: (_vm.imageInnerStyles)\n  }, [_c('img', {\n    staticClass: \"pixelParallel-image\",\n    style: (_vm.imageStyles),\n    attrs: {\n      \"alt\": \"PixelParallel Image\",\n      \"src\": _vm.image.base64string\n    }\n  })])])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-21a808b9!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/OverlayImage.vue\n// module id = 54\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', {\n    staticClass: \"btn btn-block btn-file\"\n  }, [_vm._v(\"\\n  \" + _vm._s(_vm.title) + \"\\n\\n  \"), _c('input', {\n    attrs: {\n      \"type\": \"file\"\n    },\n    on: {\n      \"change\": _vm.changeHandler\n    }\n  })])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-243bab3e!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/UploadButton.vue\n// module id = 55\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', {\n    staticClass: \"paste-box mousetrap\",\n    attrs: {\n      \"title\": _vm.title,\n      \"contenteditable\": \"true\"\n    },\n    on: {\n      \"paste\": _vm.pasteHandler\n    }\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-45f08ef4!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/PasteBox.vue\n// module id = 56\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: ({\n        x: true,\n        y: true,\n        onDragEnd: _vm.handleDragEnd,\n        onDragMove: _vm.handleDragMove,\n        onDragStart: _vm.handleDragStart\n      }),\n      expression: \"{x: true, y: true, onDragEnd: handleDragEnd, onDragMove: handleDragMove, onDragStart: handleDragStart}\"\n    }],\n    class: ['pixelParallel-panel', {\n      'pixelParallel-panel-minimized': _vm.config.minimized,\n      'pixelParallel-panel-dragging': this.dragging\n    }],\n    style: (_vm.panelInlineStyles)\n  }, [_c('div', {\n    staticClass: \"pixelParallel-panel-inner\"\n  }, [_c('div', {\n    staticClass: \"pixelParallel-panel-handle\"\n  }), _vm._v(\" \"), _c('iframe', {\n    staticClass: \"pixelParallel-panel-isolator\",\n    attrs: {\n      \"frameborder\": \"0\"\n    }\n  }), _vm._v(\" \"), _c('div', {\n    class: ['pixelParallel-panel-content', {\n      'pixelParallel-panel-content-minimized': _vm.config.minimized\n    }]\n  }, [_c('droparea', {\n    attrs: {\n      \"title\": \"Drop Here\",\n      \"on-upload\": _vm.handleImageChange\n    }\n  }), _vm._v(\" \"), _c('header', {\n    staticClass: \"header\"\n  }, [_c('div', {\n    staticClass: \"panel-control\"\n  }, [_c('ul', [_c('li', [_c('a', {\n    class: {\n      'active': !_vm.config.visible\n    },\n    attrs: {\n      \"href\": \"#\",\n      \"title\": \"Hide All Elements\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.visible = !_vm.config.visible\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-eye-slash-small\"\n  })])]), _vm._v(\" \"), _c('li', [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.minimized = !_vm.config.minimized\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-minimize\"\n  }), _vm._v(\" \"), _c('i', {\n    staticClass: \"ico ico-maximize\"\n  })])]), _vm._v(\" \"), _c('li', [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.handleCloseClick($event)\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-close\"\n  })])])])]), _vm._v(\" \"), _c('nav', {\n    staticClass: \"nav\"\n  }, [_c('ul', [_c('li', {\n    class: {\n      'current': _vm.config.currentPane === 'image'\n    }\n  }, [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.setCurrentPane('image')\n      }\n    }\n  }, [_vm._v(\"Image\")])]), _vm._v(\" \"), _c('li', {\n    class: {\n      'current': _vm.config.currentPane === 'grid'\n    }\n  }, [_c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.setCurrentPane('grid')\n      }\n    }\n  }, [_vm._v(\"Grid \"), _c('span', {\n    staticClass: \"ad\"\n  }, [_vm._v(\"and Rulers\")])])])])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"main\"\n  }, [_c('div', {\n    staticClass: \"panes\"\n  }, [(_vm.config.currentPane === 'image') ? _c('div', {\n    staticClass: \"pane\"\n  }, [_c('div', {\n    staticClass: \"row row-head row-head-large-gutter\"\n  }, [_c('div', {\n    staticClass: \"col col-2-of-5\"\n  }, [_c('upload-button', {\n    attrs: {\n      \"title\": \"Upload Image\",\n      \"on-upload\": _vm.handleImageChange\n    }\n  })], 1), _vm._v(\" \"), _vm._m(0), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-2-of-5\"\n  }, [_c('paste-box', {\n    attrs: {\n      \"title\": \"Paste Here\",\n      \"on-paste\": _vm.handleImageChange\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"row row-head\"\n  }, [_c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Top\"\n    },\n    model: {\n      value: (_vm.config.image.top),\n      callback: function($$v) {\n        _vm.config.image.top = $$v\n      },\n      expression: \"config.image.top\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Left\"\n    },\n    model: {\n      value: (_vm.config.image.left),\n      callback: function($$v) {\n        _vm.config.image.left = $$v\n      },\n      expression: \"config.image.left\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Opacity\",\n      \"arrows\": true,\n      \"step\": .1,\n      \"min\": 0,\n      \"max\": 1\n    },\n    model: {\n      value: (_vm.config.image.opacity),\n      callback: function($$v) {\n        _vm.config.image.opacity = $$v\n      },\n      expression: \"config.image.opacity\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Scale\",\n      \"min\": 0,\n      \"max\": 3,\n      \"step\": .05\n    },\n    model: {\n      value: (_vm.config.image.scale),\n      callback: function($$v) {\n        _vm.config.image.scale = $$v\n      },\n      expression: \"config.image.scale\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"row\"\n  }, [_c('div', {\n    staticClass: \"col\"\n  }, [_c('div', {\n    staticClass: \"icon-link-group\"\n  }, [_c('a', {\n    staticClass: \"icon-link\",\n    class: {\n      'active': _vm.config.image.difference\n    },\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.image.difference = !_vm.config.image.difference\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-color\"\n  }), _vm._v(\" \"), _c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(\"Color Diff\")])]), _vm._v(\" \"), _c('a', {\n    staticClass: \"icon-link\",\n    class: {\n      'active': _vm.config.image.lock\n    },\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.image.lock = !_vm.config.image.lock\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-lock\"\n  }), _vm._v(\" \"), _c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(\"Lock\")])]), _vm._v(\" \"), _c('a', {\n    staticClass: \"icon-link\",\n    class: {\n      'active': !_vm.config.image.enabled\n    },\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.config.image.enabled = !_vm.config.image.enabled\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ico ico-eye-slash\"\n  }), _vm._v(\" \"), _c('span', {\n    staticClass: \"text\"\n  }, [_vm._v(\"Hide Image\")])])])])])]) : _vm._e(), _vm._v(\" \"), (_vm.config.currentPane === 'grid') ? _c('div', {\n    staticClass: \"pane\"\n  }, [_c('div', {\n    staticClass: \"row row-head\"\n  }, [_c('div', {\n    staticClass: \"col col-1-of-3\"\n  }, [_c('toggle', {\n    attrs: {\n      \"title\": \"Layout Grid\"\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.enabled),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.enabled = $$v\n      },\n      expression: \"config.horizontalGrid.enabled\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-3\"\n  }, [_c('toggle', {\n    attrs: {\n      \"title\": \"Baseline Grid\"\n    },\n    model: {\n      value: (_vm.config.verticalGrid.enabled),\n      callback: function($$v) {\n        _vm.config.verticalGrid.enabled = $$v\n      },\n      expression: \"config.verticalGrid.enabled\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-3\"\n  }, [_c('toggle', {\n    attrs: {\n      \"title\": \"Rulers\",\n      \"action\": {\n        text: '(reset)',\n        handler: this.handleRulersReset\n      }\n    },\n    model: {\n      value: (_vm.config.rulers.enabled),\n      callback: function($$v) {\n        _vm.config.rulers.enabled = $$v\n      },\n      expression: \"config.rulers.enabled\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"row row-head\"\n  }, [_c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Width\",\n      \"min\": 0\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.width),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.width = $$v\n      },\n      expression: \"config.horizontalGrid.width\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Columns\",\n      \"min\": 0\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.columns),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.columns = $$v\n      },\n      expression: \"config.horizontalGrid.columns\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Gutter\",\n      \"min\": 0\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.gutter),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.gutter = $$v\n      },\n      expression: \"config.horizontalGrid.gutter\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Opacity\",\n      \"arrows\": true,\n      \"step\": .1,\n      \"min\": 0,\n      \"max\": 1\n    },\n    model: {\n      value: (_vm.config.horizontalGrid.opacity),\n      callback: function($$v) {\n        _vm.config.horizontalGrid.opacity = $$v\n      },\n      expression: \"config.horizontalGrid.opacity\"\n    }\n  })], 1)]), _vm._v(\" \"), _c('div', {\n    staticClass: \"row\"\n  }, [_c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Baseline\",\n      \"min\": 1\n    },\n    model: {\n      value: (_vm.config.verticalGrid.gutter),\n      callback: function($$v) {\n        _vm.config.verticalGrid.gutter = $$v\n      },\n      expression: \"config.verticalGrid.gutter\"\n    }\n  })], 1), _vm._v(\" \"), _c('div', {\n    staticClass: \"col col-1-of-4\"\n  }, [_c('number', {\n    attrs: {\n      \"title\": \"Opacity\",\n      \"arrows\": true,\n      \"step\": .1,\n      \"min\": 0,\n      \"max\": 1\n    },\n    model: {\n      value: (_vm.config.verticalGrid.opacity),\n      callback: function($$v) {\n        _vm.config.verticalGrid.opacity = $$v\n      },\n      expression: \"config.verticalGrid.opacity\"\n    }\n  })], 1)])]) : _vm._e()])])], 1)], 1)])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"col col-1-of-5\"\n  }, [_c('span', {\n    staticClass: \"elements-divider\"\n  }, [_vm._v(\"or\")])])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-54cb82b4!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/Panel.vue\n// module id = 57\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('label', {\n    class: ['toggle', {\n      'toggle-checked': _vm.checked\n    }]\n  }, [_c('span', {\n    staticClass: \"toggle-title\"\n  }, [_vm._v(_vm._s(_vm.title) + \" \"), (_vm.action) ? _c('a', {\n    attrs: {\n      \"href\": \"#\"\n    },\n    on: {\n      \"click\": function($event) {\n        $event.preventDefault();\n        _vm.action.handler($event)\n      }\n    }\n  }, [_vm._v(_vm._s(_vm.action.text))]) : _vm._e()]), _vm._v(\" \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.checked),\n      expression: \"checked\"\n    }],\n    staticClass: \"toggle-checkbox\",\n    attrs: {\n      \"type\": \"checkbox\"\n    },\n    domProps: {\n      \"checked\": Array.isArray(_vm.checked) ? _vm._i(_vm.checked, null) > -1 : (_vm.checked)\n    },\n    on: {\n      \"__c\": function($event) {\n        var $$a = _vm.checked,\n          $$el = $event.target,\n          $$c = $$el.checked ? (true) : (false);\n        if (Array.isArray($$a)) {\n          var $$v = null,\n            $$i = _vm._i($$a, $$v);\n          if ($$c) {\n            $$i < 0 && (_vm.checked = $$a.concat($$v))\n          } else {\n            $$i > -1 && (_vm.checked = $$a.slice(0, $$i).concat($$a.slice($$i + 1)))\n          }\n        } else {\n          _vm.checked = $$c\n        }\n      }\n    }\n  }), _vm._v(\" \"), _vm._m(0)])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('span', {\n    staticClass: \"toggle-main\"\n  }, [_c('span', {\n    staticClass: \"toggle-handle\"\n  })])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-601c0122!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/Toggle.vue\n// module id = 58\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    class: ['pixelParallel-rulers', {\n      'pixelParallel-rulers-enabled': _vm.config.rulers.enabled\n    }]\n  }, [_c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: ({\n        y: true,\n        onDragEnd: _vm.handleXDragEnd\n      }),\n      expression: \"{y: true, onDragEnd: handleXDragEnd}\"\n    }],\n    staticClass: \"pixelParallel-ruler-x\",\n    style: ({\n      'margin-top': ((_vm.config.rulers.x) + \"px\")\n    })\n  }), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"draggable\",\n      rawName: \"v-draggable\",\n      value: ({\n        x: true,\n        onDragEnd: _vm.handleYDragEnd\n      }),\n      expression: \"{x: true, onDragEnd: handleYDragEnd}\"\n    }],\n    staticClass: \"pixelParallel-ruler-y\",\n    style: ({\n      'margin-left': ((_vm.config.rulers.y) + \"px\")\n    })\n  })])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-72cc98cf!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/OverlayRulers.vue\n// module id = 59\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    class: ['droparea', {\n      'enabled': _vm.enabled\n    }]\n  }, [_c('span', {\n    staticClass: \"droparea-title\"\n  }, [_vm._v(_vm._s(_vm.title))]), _vm._v(\" \"), _c('input', {\n    attrs: {\n      \"type\": \"file\"\n    },\n    on: {\n      \"change\": _vm.changeHandler\n    }\n  })])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-7afe2c4a!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/Droparea.vue\n// module id = 60\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('label', {\n    staticClass: \"number\"\n  }, [_c('span', {\n    staticClass: \"number-title\"\n  }, [_vm._v(_vm._s(_vm.title))]), _vm._v(\" \"), _c('span', {\n    staticClass: \"number-field\"\n  }, [(_vm.arrows) ? _c('span', {\n    staticClass: \"number-arrows\"\n  }, [_c('span', {\n    staticClass: \"number-arrow number-arrow-up\",\n    on: {\n      \"mousedown\": function($event) {\n        $event.preventDefault();\n        _vm.startIncrement($event, _vm.step)\n      }\n    }\n  }, [_vm._v(\"+\")]), _vm._v(\" \"), _c('span', {\n    staticClass: \"number-arrow number-arrow-down\",\n    on: {\n      \"mousedown\": function($event) {\n        $event.preventDefault();\n        _vm.startIncrement($event, -_vm.step)\n      }\n    }\n  }, [_vm._v(\"-\")])]) : _vm._e(), _vm._v(\" \"), _c('input', {\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: (_vm.inputVal),\n      expression: \"inputVal\"\n    }],\n    staticClass: \"number-input\",\n    attrs: {\n      \"type\": \"number\",\n      \"step\": _vm.step,\n      \"min\": _vm.min,\n      \"max\": _vm.max\n    },\n    domProps: {\n      \"value\": (_vm.inputVal)\n    },\n    on: {\n      \"input\": function($event) {\n        if ($event.target.composing) { return; }\n        _vm.inputVal = $event.target.value\n      },\n      \"blur\": function($event) {\n        _vm.$forceUpdate()\n      }\n    }\n  })])])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-7b8b1e97!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/Number.vue\n// module id = 61\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    class: ['pixelParallel-overlay', {\n      'pixelParallel-overlay-enabled': _vm.config.visible\n    }]\n  }, [_c('overlayGrids', {\n    attrs: {\n      \"config\": _vm.config\n    }\n  }), _vm._v(\" \"), _c('overlayImage', {\n    attrs: {\n      \"config\": _vm.config,\n      \"image\": _vm.image\n    }\n  }), _vm._v(\" \"), _c('overlayRulers', {\n    attrs: {\n      \"config\": _vm.config\n    }\n  })], 1)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-9780cf1c!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/Overlay.vue\n// module id = 62\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"pixelParallel-grids\"\n  }, [_c('div', {\n    class: ['pixelParallel-grid-horizontal', {\n      'pixelParallel-grid-horizontal-enabled': _vm.config.horizontalGrid.enabled\n    }],\n    style: (_vm.horizontalGridStyles)\n  }, _vm._l(((parseInt(_vm.config.horizontalGrid.columns) || 1)), function(val) {\n    return _c('span')\n  })), _vm._v(\" \"), _c('div', {\n    class: ['pixelParallel-grid-vertical', {\n      'pixelParallel-grid-vertical-enabled': _vm.config.verticalGrid.enabled\n    }],\n    style: (_vm.verticalGridStyles)\n  })])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-b944b76a!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/OverlayGrids.vue\n// module id = 63\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js?minimize!../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-02abf5a2!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./PixelParallel.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"0a9ac382\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader!./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-02abf5a2!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/PixelParallel.vue\n// module id = 64\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js?minimize!../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-21a808b9!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./OverlayImage.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"65692d52\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader!./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-21a808b9!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/OverlayImage.vue\n// module id = 65\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js?minimize!../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-54cb82b4&scoped=true!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./Panel.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"50d13449\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader!./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-54cb82b4&scoped=true!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/Panel.vue\n// module id = 66\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js?minimize!../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-72cc98cf!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./OverlayRulers.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"41341762\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader!./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-72cc98cf!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/OverlayRulers.vue\n// module id = 67\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js?minimize!../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-9780cf1c!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./Overlay.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"454c1251\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader!./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-9780cf1c!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/Overlay.vue\n// module id = 68\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js?minimize!../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-b944b76a!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./OverlayGrids.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"aa5febfc\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader!./~/css-loader?minimize!./~/vue-loader/lib/style-rewriter.js?id=data-v-b944b76a!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/OverlayGrids.vue\n// module id = 69\n// module chunks = 0","/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/lib/listToStyles.js\n// module id = 70\n// module chunks = 0","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vuvuzela/index.js\n// module id = 71\n// module chunks = 0"],"sourceRoot":""}